<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Desenvolvimento | Flávio Silveira]]></title>
  <link href="http://flaviosilveira.com/blog/categories/desenvolvimento/atom.xml" rel="self"/>
  <link href="http://flaviosilveira.com/"/>
  <updated>2019-02-27T19:19:05+00:00</updated>
  <id>http://flaviosilveira.com/</id>
  <author>
    <name><![CDATA[Flávio Silveira]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Entenda Como Funciona O PHP! (Do Código Fonte até a Renderização)]]></title>
    <link href="http://flaviosilveira.com/2019/entenda-como-funciona-o-php-do-codigo-fonte-ate-a-renderizacao"/>
    <updated>2019-02-27T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2019/entenda-como-funciona-o-php-do-codigo-fonte-ate-a-renderizacao</id>
    <content type="html"><![CDATA[<p>Esse artigo é quase uma tradução fiel do artigo <a href="https://www.sitepoint.com/how-php-executes-from-source-code-to-render">How PHP Executes from Source Code to Render</a> de <a href="https://twitter.com/tpunt94">Thomas Punt</a>, revisado por <a href="https://twitter.com/rafieyounes">Younes Rafie</a>.</p>

<p>No original o autor coloca os pedaços de códigos para você testar por conta. Aqui, além disso, adicionei como rodar os mesmos com um único comando, usando docker. Assim você não precisa de muito esforço para ver os exemplos.</p>

<p>Criei uma imagem no dockerhub com tudo necessário para rodar os exemplos desse artigo. Basta ter o docker instalado e rodar os comandos como mostrados.</p>

<p>Acaba não sendo uma tradução fiel, pois tomei a liberdade de adicionar e tirar algumas partes de texto em relação ao original. E por ter muitos termos técnicos, posso ter pisado na bola ao traduzir ou manter no inglês algum termo em específico. Fiz isso para tentar deixar mais didático do meu ponto de vista. E isso não foi tão simples. Então, não deixe de comentar caso veja algo errado / estranho&hellip;</p>

<!-- more -->


<h2>4 etapas</h2>

<p>Bastante coisa acontece quando você executa um pequeno trecho de código PHP. De maneira geral podemos dizer que o Interpretador do PHP passa por 4 etapas quando o código é executado:</p>

<ul>
<li>Tokenização (Ou Lexing ou Scanning)</li>
<li>Parsing</li>
<li>Compilação</li>
<li>Interpretação</li>
</ul>


<p>Abaixo vamos passar por cada um dessas etapas e ver como podemos checar a saída de cada um deles para entender o que realmente acontece. Para isso vamos usar algumas extensões que já vem com PHP nativamente (como Tokenizer e o OPCache) e outras que não (como php-ast e o VLD).</p>

<h2>Tokenização</h2>

<p>Também chamada de Lexing ou de Scanning por alguns outros autores.</p>

<p>Essa etapa faz um processo de pegar um texto (um código PHP nesse caso) e transformar ele em uma sequência de tokens. Um token é simplesmente um identificador, e esse identificador vai indicar um valor.</p>

<p>O PHP usa o <a href="http://re2c.org/">re2c</a> para gerar esses tokens a partir do arquivo de configuração <a href="https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l">zend_language_scanner.l</a>.</p>

<p>Vamos ver a saída dessa etapa usando a extensão <a href="http://php.net/manual/en/book.tokenizer.php">Tokenizer</a>, nativa no PHP.</p>

<pre><code>$code = &lt;&lt;&lt;'code'
&lt;?php
$a = 1;
code;

$tokens = token_get_all($code);

foreach ($tokens as $token) {
    if (is_array($token)) {
        echo "Line {$token[2]}: ", token_name($token[0]), " ('{$token[1]}')", PHP_EOL;
    } else {
        var_dump($token);
    }
}
</code></pre>

<p>Salve o código acima em um arquivo (por exemplo, tokenizer.php), em seguida rode o container para executar ele.</p>

<p><code>docker run --rm -v "$PWD":/myapp -w /myapp flaviosilveira/php-source-to-render php tokenizer.php</code></p>

<p>Explicando rapidamente o comando docker acima:</p>

<ul>
<li><strong>&ndash;rm</strong> para remover o container automaticamente.</li>
<li><strong>-v &ldquo;$PWD&rdquo;:/myapp</strong> para compartilhar seu diretório atual com o diretório &lsquo;myapp&rsquo; do container.</li>
<li><strong>-w /myapp</strong> é uma opção para indicar o local de trabalho para o php, workspace, o document root.</li>
<li><strong>flaviosilveira/php-source-to-render</strong> é a imagem para construir o container.</li>
</ul>


<p>Saída:</p>

<pre><code>Line 1: T_OPEN_TAG ('&lt;?php
')
Line 2: T_VARIABLE ('$a')
Line 2: T_WHITESPACE (' ')
string(1) "="
Line 2: T_WHITESPACE (' ')
Line 2: T_LNUMBER ('1')
string(1) ";"
</code></pre>

<p>Coisas para considerarmos da saída acima:</p>

<ul>
<li>Nem todos os pedaços do código se transformam em Tokens. Alguns símbolos já são considerados tokens por si só (=, ;, :, ?, e outros).</li>
<li>Será armazenado o valor correspondente do token e o número da linha desse token para o stack trace. Aquele mesmo que vemos em algumas mensagens de erro tentando nos ajudar quando temos problemas.</li>
</ul>


<h2>Parsing</h2>

<p>Essa etapa de parsing, pega a saÃ­da da etapa de tokenização e executa duas tarefas:</p>

<p>A primeira tarefa: Valida a ordem dos tokens com as regras da linguagem definidas no <a href="https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y">BNF grammar file</a>. Isso garante que as regras de sintaxe da linguagem estão sendo seguidas. Essa etapa conta com o <a href="https://www.gnu.org/software/bison/">Bison</a> (Não é Street Fighter, é Open Source) e usa o contexto <strong>LARL</strong>, Look Ahead, Left to right, ou seja, faz a leitura em frente, enquanto achar tokens, da esquerda para a direita.</p>

<p>A segunda tarefa: Gerar uma árvore de sintaxe abstrata, no inglês AST (Abstract Sintaxe Tree), uma árvore do código fonte que será usada durante a próxima etapa.</p>

<p>Podemos ver a forma dessa AST produzida pelo parser usando a extensão <a href="https://github.com/nikic/php-ast">php-ast</a> do excelente <a href="https://github.com/nikic">Nikita Popov</a>.</p>

<pre><code>$code = &lt;&lt;&lt;'code'
&lt;?php
$a = 1;
code;

print_r(ast\parse_code($code, 60));
</code></pre>

<h5>Importante</h5>

<p>O número 60 dentro do print_r acima, se refere a versão. 60 é a versão no momento de escrita dese artigo (Na versão original em inglês era 30). Caso dê erro, a saída do mesmo te mostrará a versão atual. Basta trocar.</p>

<p>Salve o código acima em um arquivo (por exemplo, parsing.php), em seguida rode o container para executar ele:</p>

<p><code>docker run --rm -v "$PWD":/myapp -w /myapp flaviosilveira/php-source-to-render php parsing.php</code></p>

<p>Saída:</p>

<pre><code>ast\Node Object (
    [kind] =&gt; 132
    [flags] =&gt; 0
    [lineno] =&gt; 1
    [children] =&gt; Array (
        [0] =&gt; ast\Node Object (
            [kind] =&gt; 517
            [flags] =&gt; 0
            [lineno] =&gt; 2
            [children] =&gt; Array (
                [var] =&gt; ast\Node Object (
                    [kind] =&gt; 256
                    [flags] =&gt; 0
                    [lineno] =&gt; 2
                    [children] =&gt; Array (
                        [name] =&gt; a
                    )
                )
                [expr] =&gt; 1
            )
        )
    )
)
</code></pre>

<p>A árvore de nós, que geralmente são do tipo <strong>ast\Node</strong>, tem várias propriedades:</p>

<ul>
<li>kind - Um valor inteiro para representar o tipo de nó. Cada um tem uma constante correspondente (AST_STMT_LIST => 132, AST_ASSIGN => 517, AST_VAR => 256).</li>
<li>flags - Um inteiro que específico comportamento de sobrecarga. Por exemplo, um nó ast\AST_BINARY_OP terá flags para diferenciar qual operação binária está ocorrendo.</li>
<li>lineno - O número da linha, como visto na informação do token anteriormente.</li>
<li>children - Sub-Nós. Por exemplo uma função vai apresentar como children: parâmetros, tipo do retorno, corpo, etc.</li>
</ul>


<p>Essa saída AST dessa etapa é útil para ferramentas como analisadores de código, por exemplo o <a href="https://github.com/phan/phan">Phan</a>.</p>

<h2>Compilação</h2>

<p>A etapa de compilação consome a AST gerada acima. Gerando Opcodes (Operation Codes) recursivamente enquanto percorre a árvore. Opcodes são operações a serem executadas.</p>

<p>Essa etapa também executa algumas otimizações. Isso inclui resolver algumas chamadas de função com argumentos literais (strlen(&ldquo;abc&rdquo;) para int(3)) e expressões matemáticas (60 * 60 * 24 para int(86400)).</p>

<p>Há algumas maneiras de vermos os Opcodes gerados nessa etapa. Mas hoje vamos de <a href="https://derickrethans.nl/projects.html#vld">VLD</a>, criada pelo <a href="https://twitter.com/derickr">Derick Rethans</a>. Essa ferramenta mostra a saída de uma maneira mais amigável do que as demais, e isso ajuda no nosso entendimento.</p>

<p>Vamos ver a saída para o seguinte código:</p>

<pre><code>if (PHP_VERSION == '7.2.15') {
    echo 'Yay', PHP_EOL;
}
</code></pre>

<p>Salve o código acima em um arquivo (por exemplo, compilation.php), em seguida rode o container para executar ele:</p>

<p><code>docker run --rm -v "$PWD":/myapp -w /myapp flaviosilveira/php-source-to-render php -dvld.active=1 compilation.php</code></p>

<p>Saída:</p>

<pre><code>line     #* E I O op                           fetch          ext  return  operands
-------------------------------------------------------------------------------------
   3     0  E &gt; &gt; JMPZ                                                     &lt;true&gt;, -&gt;3
   4     1    &gt;   ECHO                                                     'Yay'
         2        ECHO                                                     '%0A'
   6     3    &gt; &gt; RETURN                                                   1
</code></pre>

<p>De certa forma os Opcodes se parecem com o código fonte original, permitindo acompanhar as operações básicas. (Esse artigo não tem a pretensão de detalhar Opcodes.) Nenhuma otimização foi aplicada no nível do código de operação no script acima, mas podemos ver que essa etapa de compilação resolveu por exemplo a condição (1 == &lsquo;1&rsquo;) para true.</p>

<p>Nessa etapa também, entram em ação ferramentas que fazem o cache dos Opcodes, evitando assim refazer as etapas de tokenização, parsing e compilação com frequência. Entre essas ferramentas temos o apc e o OPCache.</p>

<p>O OPCache, além de fazer isso também tem alguns passos de otimização. Alterando o parâmetro dopcache.optimization_level, podemos aumentar o nível de otimização e ver o que acontece:</p>

<h5>Importante</h5>

<p>Precisamos também habilitar o OPCache para cli, com o parâmetro dopcache.enable_cli para vermos a saída.</p>

<p><code>docker run --rm -v "$PWD":/myapp -w /myapp flaviosilveira/php-source-to-render php -dopcache.enable_cli=1 -dopcache.optimization_level=1111 -dvld.active=1 -dvld.execute=0 code/compilation.php</code></p>

<p>Saída:</p>

<pre><code>line     #* E I O op                           fetch          ext  return  operands
-------------------------------------------------------------------------------------
   4     0  E &gt;   ECHO                                                     'Yay%0A'
   6     1      &gt; RETURN                                                   1
</code></pre>

<p>Vemos que a condicional foi removida e as duas instruções com ECHO se tornaram uma só. Isso é só um gostinho das otimizações que o OPCache aplica. Esse artigo não vai entrar nos detalhes dos níveis de otimização por ser um assunto extenso.</p>

<h5>Importante</h5>

<p>Você pode adicionar os parâmetros -dvld.save_paths e -dvld.save_dir para salvar essa saída com os Opcodes em um arquivo que você poderá abrir com o <a href="http://graphviz.org/">Graphiz</a>. Fica muito legal para estudar!</p>

<h2>Interpretação</h2>

<p>A útima etapa é a interpretação dos Opcodes. Aqui os Opcodes são executados na VM Zend Engine (ZE). Não há muito o que dizer sobre essa etapa (ao menos de um ponto de vista de alto nível). A saída é praticamente igual a saída de seus códigos usando comandos como echo, print, var_dump e etc.</p>

<p>Então, ao invés de entrar em algo muito complexo nessa etapa, aqui está um fato divertido: o PHP chama a si mesmo como uma dependência quando gera sua própria VM. Isso porque a VM é gerada por um script PHP, para ser mais simples de escrever e mais fácil de manter.</p>

<h2>Conclusão</h2>

<p>Demos aqui uma rápida olhada pelas 4 etapas que o interpretador do PHP passa quando executa um código. Isso envolveu o uso de algumas extensões como Tokenizer, OPCache, php-ast e VLD para manipular e ver a saída de cada etapa.</p>

<p>Que esse artigo ajude a espalhar um melhor entendimento sobre o interpretador do PHP, e também que mostre a importância do estágio de cache na etapa de compilação.</p>

<p>Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ferramentas De Otimização De Imagem via Linha De Comdo]]></title>
    <link href="http://flaviosilveira.com/2019/ferramentas-de-otimizacao-de-imagem-via-linha-de-comando"/>
    <updated>2019-02-18T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2019/ferramentas-de-otimizacao-de-imagem-via-linha-de-comando</id>
    <content type="html"><![CDATA[<p>Na última semana durante um trabalho de otimização de performance para um site, chegou a hora das imagens. Muitas imagens antigas de produtos e também peças de layout que tinham bom espaço para ganho. Diminuir o tamanho dos arquivos sem perder tanto as cores e a qualidade gráfica das imagens.</p>

<p>Eu estava procurando por ferramentas para otimizar as imagens de uma maneira que eu pudesse fazer diretamente no servidor, via terminal. Dessa forma eu não precisaria fazer o download de tudo para minha máquina, depois subir novamente e nem nada similar. Apenas um Backup no próprio servidor e rodar os comandos.</p>

<!--more-->


<p>Haviam imagens das famílias PNG, GIF e JPG e acabei chegando nas seguintes ferramentas:</p>

<ul>
<li>jpegoptim</li>
<li>optiPNG</li>
<li>gifsicle</li>
</ul>


<p>Todas as três instaladas via apt-get e similares, super leves, fácéis de instalar e também de usar, como mostro a seguir:</p>

<h3>jpegoptim</h3>

<p>Uso simples:</p>

<p><code>jpegoptim filename.jpg</code></p>

<p>Seu arquivo pode ser jpg, jpeg, JPG, JPEG, &hellip;</p>

<p>O comando acima, faz a otimização mantendo a qualidade da imagem, o que queremos. Mas você pode também passar um parâmetro para controlar isso.</p>

<p>Tive excelentes resultados sem muita perda de qualidade e com excelentes ganhos de compressão com o seguinte comando:</p>

<p><code>jpegoptim --max=80 filename.jpg</code></p>

<h3>optiPNG</h3>

<p>Uso simples:</p>

<p><code>optipng filename.png</code></p>

<p>Seu arquivo pode ser png, PNG, etc.</p>

<p>Diferente da ferramenta anterior para jpg, essa não permite parâmetros considerando perda de qualidade por conta do formato PNG e como ele foi concebido.</p>

<h3>gifsicle</h3>

<p>Uso simples:</p>

<p><code>gifsicle --batch --optimize=3 filename.gif</code></p>

<p><strong>&ndash;batch</strong> é o parâmetro para dizer que você quer manter o arquivo no mesmo lugar e com o mesmo nome.</p>

<p><strong>&ndash;optimize</strong> é um parâmtro que determina o nível de otimização. 3 é uma opção que tenta vários métodos em cima da imagem. Consulte o manual parr
a as outras opções.</p>

<p>Seu arquivo pode ser gif, GIF, ..</p>

<p>Em caso de gifs animados, dê uma lida no manual. Existem alguns parâmetros adicionais para otimização de animações.</p>

<h3>Várias imagens de uma vez só</h3>

<p>Para rodar os comandos acima em várias imagens, dentro de vários diretórios, use a opção <strong>-exec</strong> do comando <strong>find</strong></p>

<p><code>find -name '*.png' -exec optipng {} \;</code></p>

<p><strong>-name</strong> para buscar por nome dos arquivos</p>

<p><strong>.png</strong> irá buscar por arquivos com a extensão .png. Não esqueça das aspas.</p>

<p>Após o <strong>-exec</strong> adicione o comando que você quer executar para todas as ocorrências que serão encontradas.</p>

<p><strong>{}</strong> As chaves representam as ocorrências encontradas.</p>

<p>Feche com <strong>\;</strong></p>

<p>Antes de sair executando essa combinação, teste com um <em>ls -l</em> no lugar do comando. Assim você verá o que o <strong>find</strong> vai retornar. E claro, faço um backup das imagens em outra pasta para evitar maiores problemas.</p>

<h3>man</h3>

<p>Todas as ferramentas acima possuem um manual bem completo e fácil de compreender. Basta digitar <strong>man</strong> e o nome da ferramenta para acessar.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quer Estudar Uma Coisa Nova? Docker Te Ajuda!]]></title>
    <link href="http://flaviosilveira.com/2019/quer-estudar-uma-coisa-nova-docker-te-ajuda"/>
    <updated>2019-01-25T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2019/quer-estudar-uma-coisa-nova-docker-te-ajuda</id>
    <content type="html"><![CDATA[<p>Sempre que vamos estudar algo em tecnologia, em programação temos a complexidade do ambiente para resolver. Para um simples <strong>Hello World</strong> precisamos de um ambiente e a complexidade da criação dele pode desanimar os iniciantes (Por isso o JavaScript vem a ser execelente para os iniciantes!).</p>

<p>Mas para ajudar com isso temos os containers e uma ferramenta excelente para trabalhar com eles, o Docker. Diferente de uma máquina virtual, o container vai abranger apenas o que é necessário para rodar sua aplicação, sem precisar de um SO completo.</p>

<p>Vamos dizer então que você quer estudar algo diferente, um banco de dados de grafos e vamos entender como o Docker vai te ajudar com isso.</p>

<!--more-->


<h2>Pesquise</h2>

<p>Então até aqui já temos alguns nomes que podem ser novos para alguns.</p>

<h3>Docker</h3>

<p>Se você não conhece docker, dê uma buscada sobre. É uma ferramenta que pode mudar sua maneira de pensar em ambientes, arquiteturas e até sua maneira de desenvolver.</p>

<h3>Banco de dados de Grafos</h3>

<p>Outro ponto são bancos de dados de Grafos. Pesquise, veja suas aplicações, leia os conceitos. Busque pela solução do problema do caminho mínimo, do caixeiro viajante e outros similares.</p>

<h2>Neo4J</h2>

<p>O Neo4J se tornou um bancos de dados de grafos muito conhecido. Pode ser pela sua interface gráfica ou pelo seu tutorial passo a passo que te mostra algumas coisas legais de entender com grafos.</p>

<p>Ele não é o foco desse artigo mas espero que traga algo para bater na cabeça de vocês.</p>

<h2>O Docker te ajudando a estudar qualquer coisa</h2>

<p>Então vamos dizer que você escolheu que quer estudar grafos e chegou a conclusão que o Neo4J é bom para iniciar. Vamos ver como o docker vai te ajudar nisso.</p>

<p>Massssss&hellip;&hellip; Esse é um exemplo, o que quero mostrar é a facilidade que ele traz seja lá o que você quer estudar. Go, Java, NodeJS, PhantomJS, ferramentas, bancos de dados e outras tantas coisas. Siga os passos que vou descrever abaixo e você encontrará seu caminho.</p>

<h2>Dockerhub</h2>

<p>O Docker funciona com imagens. Uma imagem é um arquivo que contém todas (ou quase todas) as instruções para a rodar a aplicação que você precisa.</p>

<p>O <a href="https://hub.docker.com/">Dockerhub</a> é um repositório dessas imagens, e lá você pode procurar pelo o que você precisa.</p>

<p>Repare que você encontrará imagens oficiais, produzidas pelas empresas dos softwares e imagens criados por outros usuários. As oficiais, geralmente, vem com uma extensa documentação que são de grande ajuda para fazer tudo rodar certinho. Mas, um usuário pode ter tido um insight legal e acrescentado ou facilitado ainda mais o processo, então vale ficar de olho nos dois.</p>

<p>Para um futuro, vale você ver como subir suas imagens</p>

<h2>Subindo um Neo4J</h2>

<p>No Dockerhub procure por Neo4J.</p>

<p>Nos resultados da pesquisa você deve chegar na imagem oficial que está no seguinte endereço <a href="https://hub.docker.com/_/neo4j">https://hub.docker.com/_/neo4j</a>.</p>

<p>Dentrp desse repositório oficial do Neo4J você tem as versões, uma explicação do que é o Neo4J, como usar, documentacão e licença.</p>

<p>Em <strong><em>como usar essa imagem</em></strong>, você vê o comando <strong>docker run</strong> para rodar a aplicação.</p>

<p><strong><strong><em> Sim!! Você já deve ter o docker instalado em sua máquina antes de seguir em diante. Não será difícil achar tutoriais de como fazer isso par aseu sistema operacional internet a fora.</em></strong></strong></p>

<p>Vamos executar:</p>

<pre><code>docker run --publish=7474:7474 --publish=7687:7687 --volume=$HOME/neo4j/data:/data neo4j
</code></pre>

<p>Explicando esse comando temos:</p>

<ul>
<li>&ndash;publish está expondo sua porta 7474 e encaminhando ela para a porta 7474 do container.</li>
<li>O mesmo acontece com a porta 7687.</li>
<li>&ndash;volume é um caminho na sua máquina que será compatilhado com o container. Ele armazenará as mudanças de dados que você fizer, e quando você erguer novamente esse container suas alterações estarão lá.</li>
<li>Neo4J no final é o nome da imagem.</li>
</ul>


<p>A instrução &ndash;publish pode ser abreviado para -p e a instrução &ndash;volume para -v.
Você pode tirar o sinal de igual, manter, tanto faz.</p>

<p>Eu uso como abaixo:</p>

<pre><code>docker run -p 7474:7474 -p 7687:7687 -v $HOME/neo4j/data:/data neo4j
</code></pre>

<p>Essa é a saída que começa a aparecer aqui:</p>

<pre><code>Unable to find image 'neo4j:latest' locally
latest: Pulling from library/neo4j
cd784148e348: Downloading [========================================&gt;          ]  1.785MB/2.207MB
35920a071f91: Download complete 
1a5149a464dd: Downloading [=&gt;                                                 ]  1.621MB/54.87MB
15bb04bfc35a: Waiting 
...
</code></pre>

<ul>
<li>O Docker viu que eu não tinha a imagem, então foi buscar o caminho dela para fazer o download.</li>
<li>Layers, é a maneira que o docker usa para fazer o download das imagens.</li>
</ul>


<p>Na sequência disso ele vai subir a aplicação, até te dizer o seguinte:</p>

<pre><code>....
INFO  ======== Neo4j 3.5.2 ========
INFO  Starting...
INFO  Bolt enabled on 0.0.0.0:7687.
INFO  Started.
INFO  Remote interface available at http://localhost:7474/
</code></pre>

<p>Acesse conforme a saída sugere o endereço <a href="http://localhost:7474">http://localhost:7474</a> e você está na interface do Neo4J.</p>

<p>Viu como é fácil?</p>

<h2>Teste com outras ferramentas / tecnologias</h2>

<p>Acredito que não houve nenhuma dor em seguir os passos acima. É muito simples!</p>

<p>Buscar no dockerhub a tecnologia, dar uma lida em como a imagem se comporta e executar um docker run.</p>

<p>Teste com outras ferramentas, bancos de dados, sistemas, frameworks e se apaixone pelo docker assim como eu.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Como Foi 2018 E O Que Você Pode Esperar De Mim Para 2019]]></title>
    <link href="http://flaviosilveira.com/2019/como-foi-2018-e-o-que-voce-pode-esperar-de-mim-para-2019"/>
    <updated>2019-01-08T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2019/como-foi-2018-e-o-que-voce-pode-esperar-de-mim-para-2019</id>
    <content type="html"><![CDATA[<p>Em minha carreira, graças a excelentes mestres e amigos no meu caminho (cito alguns no final), eu acabei evoluindo e subindo de cargo muito rapidamente. Em poucos anos como desenvolvedor eu fui promovido para Analista e assim se seguiu para Líder de desenvolvimento e chegando até Gerente de TI.</p>

<p>Em uma dessas promoções eu cheguei a pedir demissão, pois queria me preparar melhor antes de liderar ou dar instruções para um time. Mas depois aceitei os desafios.</p>

<p>Nesses períodos eu acabei colocando a mão em código muito menos do que eu esperava. Sempre senti falta, fazia uma coisinha aqui - ali, mas tinha outras responsabilidades. E ressalto que nunca deixei de buscar sempre fazer um grande trabalho independente da posição.</p>

<p>Em 2018 muitas coisas estavam acontecendo, minha filha estava crescendo, problemas de saúde do lado da família da minha esposa e o início e crescimento de uma insatisfação no trabalho da época. Isso somado a excelentes conversas com <a href="https://twitter.com/mhgontijo">Matheus Gontijo</a>, me levaram a pedir demissão e partir para um trabalho de casa, remoto, fora do Brasil.</p>

<!--more-->


<p>Esse passo me fez ver minha posição no mercado. Excelentes empresas me chamaram para conversar e acabei conhecendo muita gente legal. Mas acabei recusando todas, queria mesmo voltar a programar e com o dólar em alta eu poderia trabalhar menos horas por dia e ganhar mais, mesmo com o pagamento dos impostos. Trabalhando menos horas por dia poderia me dedicar a minha filha, família e outros projetos (Palestrei sobre isso em 2018, Trabahe menos, Ganhe mais. Vou compartilhar em breve aqui esse conteúdo).</p>

<h2>Então resumo de 2018</h2>

<p>Larguei minha posição de Gerente para voltar a programar, algo que me fazia falta, que eu amo fazer. Trabalhando de casa, ganhando mais do que como Gerente e trabalhando 5 horas por dia. Pude passar mais tempo com minha família e filha.</p>

<p>Trabalhando menos horas por dia, dediquei o restante do tempo em vários cursos: finanças, ações na bolsa, fundos de investimento e claro desenvolvimento, programação e tecnologia.</p>

<p>Voltei a Meditar, fazer Exercícios, ler e tocar guitarra.</p>

<p>Iniciei também alguns projetos como um ECommerce e meu livro.</p>

<h2>2019</h2>

<p>Nessa mesma pegada quero iniciar e continuar esse ano de 2019.
Então segue aqui o que você pode esperar de mim para esse ano:</p>

<h3>Pessoal</h3>

<p>_ Manter o trabalho de 5 horas por dia, remoto.</p>

<p>_ Usar parte do restante do tempo e aproveitar que estou em casa para poder me alimentar melhor, meditar e fazer exercícios.</p>

<p>_ Colocar no ar o ECommerce que estou trabalhando com outros sócios.</p>

<p>_ Ler pelo menos 25 livros nesse ano (Me acompanhe no <a href="https://www.goodreads.com/">GoodReads</a>).</p>

<h3>Geração de Conteúdo</h3>

<h4>Meu livro</h4>

<p>Estou trabalhando na edição do meu livro chamado PHP Mentors - Advices from PHP Experts around the world. Será uma coleção de respostas de grandes nomes de PHP do mundo e do Brasil. Já contactei 200 desenvolvedores e líderes PHP pelo Mundo!</p>

<p>O primeiro lançamento deve acontecer em Junho e essa primeira versão será em inglês. Mais informações em breve ou se quiser já vai acompanhando aqui <a href="https://leanpub.com/php-mentors">https://leanpub.com/php-mentors</a>.</p>

<h4>Screencasts e vídeos</h4>

<p>Código, vida, Tecnologia e música. Estou preparando a gravação de Screencasts e vídeos que estarão no youtube. A ideia é programar, mostrar tecnologias e trazer alguns amigos para esses vídeos para o mesmo. Serão vídeos de aproximadamente 15 minutos, divertidos e com mão na massa.</p>

<p>Um plus é que também vou colocar alguns vídeos meus tocando algumas músicas de Metal Progressivo para quem quiser ver.</p>

<h4>Blog</h4>

<p>Esse blog vai voltar a ativa (de verdade), com posts para divulgar os projetos acima e também com posts técnicos. A série <strong>**4 Drops of life</strong> onde trago alguns hackings e coisas do meu dia a dia também volta.</p>

<h2>Me cobrem</h2>

<p>É isso, bastante coisa, mas tudo já planejado e com dedicação garantida.</p>

<p>Me cobrem!</p>

<p>Vou mandando as novidades por aqui e através do meu Twitter (<a href="https://twitter.com/flaviosilveira">https://twitter.com/flaviosilveira</a>).</p>

<p>E seu ano? Como será?</p>

<h3>PS</h3>

<p>Quero citar aqui os amigos e mestres mais importantes para mim até esse ponto na minha carreira: Mozart Petter (<a href="https://twitter.com/mokkunsis">https://twitter.com/mokkunsis</a>), Fábio Tomio (<a href="https://twitter.com/fabiotomio">https://twitter.com/fabiotomio</a>), Cristiano Burg (<a href="https://twitter.com/crburg">https://twitter.com/crburg</a>), Peterson Grazek (<a href="https://twitter.com/pegrazek">https://twitter.com/pegrazek</a>), Matheus Gontijo (<a href="https://twitter.com/mhgontijo">https://twitter.com/mhgontijo</a>). Devo muito para vocês! Gratidão Eterna!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Criando Seu Container Com Dockerfile]]></title>
    <link href="http://flaviosilveira.com/2017/criando-seu-container-com-dockerfile/"/>
    <updated>2017-02-12T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2017/criando-seu-container-com-dockerfile</id>
    <content type="html"><![CDATA[<p>Foi uma longa jornada até criarmos nosso container da maneira que queríamos <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-1/">flaviosilveira.com/2017/criando-seu-container-nginx-php-1/</a> e <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2/">flaviosilveira.com/2017/criando-seu-container-nginx-php-2/</a>. Ainda assim temos alguns pontos chatos como o de ter de iniciar o Nginx e o PHP-FPM Manualmente.</p>

<p>Felizmente há uma maneira mais simples de montarmos nosso container e ainda fugindo do trabalho manual. Vamos usar Dockerfile!</p>

<p>Dockerfile é um arquivo onde colocamos tudo o que precisamos para nosso container. De qual container ele se origina, o que você quer instalar, que serviços quer rodar.</p>

<p>Se você está acompanhando a série de artigos sobre docker, basicamente vamos traduzir o que fizemos nos dois artigos anteriores para um Dockerfile.</p>

<p>No decorrer deste artigo vou me referir aos 2 anteriores praticamente o tempo todo. Caso você não os tenha lido, pode ficar um pouco fora de contexto para você, mas nada que vá comprometer o entendimento final.</p>

<!--more-->


<h3>Preparação</h3>

<p>Crie uma pasta chamada <em>docker-test</em>, e dentro dela crie um arquivo chamado <em>Dockerfile</em>. Com a inicial maiúscula e sem extensão.</p>

<p>Isso é tudo que vamos precisar.</p>

<h3>Container de origem</h3>

<p>No começo da parte 1 do artigo falamos sobre de qual container partiríamos. Entre Ubuntu e Debian, ficamos com o Debian.</p>

<p>Para dizer isso para o Dockerfile, usamos <strong>FROM</strong></p>

<pre><code>FROM debian
</code></pre>

<p>Com essa diretiva, estamos partindo da última imagem do debian presente no DockerHub.</p>

<h3>Assine sua imagem</h3>

<p>Use <em>MAINTENER</em> para assinar sua imagem, dizer aos outros quem é o mantenedor dela.
No meu caso:</p>

<pre><code>MAINTAINER Flavio Silveira
</code></pre>

<h3>Atualização e instalações</h3>

<p>Passamos algum tempo atualizando o sistema e em seguida instalando o NGinx e o PHP-FPM. Fizemos isso de fora do container usando o comando <em>docker exec</em>.</p>

<p>No Dockerfile usamos RUN para criar o ambiente da nossa imagem</p>

<pre><code>RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get install -y php5-fpm
</code></pre>

<p>Essas 3 linhas resumem muito do trabalho que foi feito na parte 1 do artigo. Elas indicam respectivamente que queremos atualizar o sistema operacional e em seguida instalar o NGinx e o php5-fpm. Simples assim!</p>

<h3>Configurações</h3>

<p>Para configurar nosso container, entramos nele com o comando <em>docker attach</em> e criamos e alteramos o arquivo <em>/etc/nginx/sites-available/default</em>. Fizemos um arquivo bem enxuto funcionando na porta <em>80</em> e apontando para <em>/var/www/app</em>.</p>

<p>Copie o trabalho que fizemos com o arquivo default dentro do container para um arquivo local, dentro de nossa pasta <em>docker-test</em>, chame ele de <em>default</em>.</p>

<p>Agora vamos dizer para o Dockerfile que queremos copiar esse arquivo para a configuração do Nginx.</p>

<pre><code>COPY default /etc/nginx/sites-available/default
</code></pre>

<p>O primeiro parâmetro é o arquivo em nossa máquina, e o segundo é o lugar que ele vai parar em nossa imagem.</p>

<p>Os passos de criar a pasta app, não serão necessários. Você vai ver como o container vai se virar com isso sem trazer a dor de cabeça para você.</p>

<h3>Fechando sua imagem</h3>

<p>Na parte 2 do artigo anterior criamos a imagem a partir do container que estavamos rodando. Infelizmente tinhamos de iniciar o NGinx e o PHP-FPM manualmente após fazer download da imagem para fazer as coisas acontecerem.</p>

<p>Aqui no Dockerfile vamos resolver esse problema.</p>

<p>Uma vez que nosso ambiente foi preparado com os comandos anteriores, agora vamos usar <em>CMD</em> para dizer como nosso container vai rodar.</p>

<pre><code>CMD service nginx start &amp;&amp; service php5-fpm start &amp;&amp; /bin/bash
</code></pre>

<p>Repare que diferente da diretiva <em>RUN</em>, com <em>CMD</em> concatenamos os comandos usando <em>&amp;&amp;</em>. Precisamos disso pois só podemos ter um <em>CMD</em> no Dockerfile.</p>

<p>Aqui respectivamente iniciarmos o Nginx, em seguida o PHP-FPM e executamos <em>/bin/bash</em> para que o container fique de pé quando iniciado.</p>

<p>Caso a gente não use esse <em>/bin/bash</em> aqui, teremos que passar ele quando rodarmos a imagem com <em>docker run</em>.</p>

<h3>Nosso Dockerfile</h3>

<p>É isso! Já temos tudo o que precisamos no nosso <em>Dockerfile</em>.
Vejam como ficou:</p>

<pre><code>FROM debian

MAINTAINER Flavio Silveira

RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get install -y php5-fpm

COPY default /etc/nginx/sites-available/default

CMD service nginx start &amp;&amp; service php5-fpm start &amp;&amp; /bin/bash
</code></pre>

<h3>Construindo a imagem</h3>

<p>Para construir a imagem a partir do Dockerfile vamos executar o comando docker build.</p>

<pre><code>docker build -t flaviosilveira/php-nginx-2 .
</code></pre>

<p>Usamos o parâmetro -t para dar a nossa imagem um apelido, uma tag para que fique mais fácil levantar ela depois. Assim como no artigo anterior, coloque seu nome de usuário do DockerHub na frente da tag da imagem. Isso será necessário na hora do envio da imagem. No meu caso ficou <em>flaviosilveira/php-nginx-2</em>.</p>

<p>O ponto no final, indica o diretório aonde está o Dockerfile que você criou.</p>

<p>Você verá o docker executar passo a passo do seu Dockerfile em detalhes, acompanhe no seu terminal.</p>

<h3>Checando sua imagem e dando run</h3>

<p>Com o comando <em>docker images</em> você vê sua imagem criada localmente. Vamos testa-lá?</p>

<pre><code>docker run --name usando-dockerfile -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx-2
</code></pre>

<p>Coloquei um nome para meu container de <em>usando-dockerfile</em>.</p>

<p>Passamos a referência de portas, a 8080 de nossa máquina vai bater na 80 do container.</p>

<p>Compartilhei uma pasta local minha <em>~/dev/php</em> para a pasta <em>/var/www/app</em> do container. Tudo que que for feito na pasta local, vai refletir na pasta dentro do container. <em>/var/www/app</em> é o local para onde nosso config do NGinx aponta como diretório raiz.</p>

<p>Faça os testes com seus arquivos PHP e veja em funcionamento.</p>

<p>Caso queira, acesse o container e confirme que seus serviços estão rodando e que o arquivo de configuração do NGinx foi copiado.</p>

<h3>Enviando ao Dockerhub</h3>

<p>Para enviar a imagem para o DockerHub, vamos fazer o mesmo processo do artigo anterior.</p>

<pre><code>docker login
</code></pre>

<p>Caso não tenha usuário no DockerHub, não esqueça de criar antes.</p>

<p>E para enviar a imagem</p>

<pre><code>docker push flaviosilveira/php-nginx-2
</code></pre>

<p>Use com a tag que deu para sua imagem, com seu nome de usuário.</p>

<p>É isso! Acesse o DockerHub para conferir.</p>

<h3>Testando</h3>

<p>Seguindo o mesmo que fizemos no final do último artigo vamos testar.</p>

<p>Antes de testar, vamos eliminar tudo que temos localmente, parar o container e remover a imagem.</p>

<pre><code>docker stop usando-dockerfile
docker rm usando-dockerfile
docker rmi flaviosilveira/php-nginx-2
</code></pre>

<p>Agora executamos o mesmo run que fizemos acima.</p>

<pre><code>docker run --name usando-dockerfile -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx-2
</code></pre>

<p>A imagem não será encontrada localmente e será feito download dela diretamente do DockerHub.</p>

<p>Veja seu container rodando:</p>

<pre><code>docker ps
</code></pre>

<p>Viram como foi muito mais fácil usar o Dockerfile para criar nosso container? Por hoje é isso!</p>

<p>Grande abraço e até a próxima.</p>
]]></content>
  </entry>
  
</feed>
