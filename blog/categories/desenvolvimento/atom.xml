<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Desenvolvimento | Flávio Silveira]]></title>
  <link href="http://flaviosilveira.com/blog/categories/desenvolvimento/atom.xml" rel="self"/>
  <link href="http://flaviosilveira.com/"/>
  <updated>2019-02-18T14:35:28+00:00</updated>
  <id>http://flaviosilveira.com/</id>
  <author>
    <name><![CDATA[Flávio Silveira]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ferramentas De Otimização De Imagem via Linha De Comando]]></title>
    <link href="http://flaviosilveira.com/2019/ferramentas-de-otimizacao-de-imagem-via-linha-de-comando"/>
    <updated>2019-02-18T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2019/ferramentas-de-otimizacao-de-imagem-via-linha-de-comando</id>
    <content type="html"><![CDATA[<p>Na última semana durante um trabalho de otimização de performance para um site, chegou a hora das imagens. Muitas imagens antigas de produtos e também peças de layout que tinham bom espaço para ganho.</p>

<p>Eu estava procurando por ferramentas para otimizar as imagens de uma maneira que eu pudesse fazer diretamente no servidor, via terminal. Dessa forma eu não precisaria fazer o download de tudo para minha máquina, depois subir novamente e nem nada similar. Apenas um Backup no próprio servidor e rodar os comandos.</p>

<!--more-->


<p>Haviam imagens das famílias PNG, GIF e JPG e acabei chegando nas seguintes ferramentas:</p>

<ul>
<li>jpegoptim</li>
<li>optiPNG</li>
<li>gifsicle</li>
</ul>


<p>Todas as três instaladas via apt-get e similares, super leves, fácéis de instalar e também de usar, como mostro a seguir:</p>

<h3>jpegoptim</h3>

<p>Uso simples:</p>

<p><code>jpegoptim filename.jpg</code></p>

<p>Seu arquivo pode ser jpg, jpeg, JPG, JPEG, &hellip;</p>

<p>O comando acima, faz a otimização mantendo a qualidade da imagem, o que queremos. Mas você pode também passar um parâmetro para controlar isso.</p>

<p>Tive excelentes resultados sem muita perda de qualidade e com excelentes ganhos de compressão com o seguinte comando:</p>

<p><code>jpegoptim --max=80 filename.jpg</code></p>

<h3>optiPNG</h3>

<p>Uso simples:</p>

<p><code>optipng filename.png</code></p>

<p>Seu arquivo pode ser png, PNG, &hellip;</p>

<p>Diferente da ferramenta anterior para jpg, essa não permite parâmetros considerando perda de qualidade por conta do formato PNG e como ele foi concebido.</p>

<h3>gifsicle</h3>

<p>Uso simples:</p>

<p><code>gifsicle --batch --optimize=3 filename.gif</code></p>

<p><strong>&ndash;batch</strong> é o parâmetro para dizer que você quer manter o arquivo no mesmo lugar e com o mesmo nome.</p>

<p><strong>&ndash;optimize</strong> é um parâmtro que determina o nível de otimização. 3 é uma opção que tenta vários métodos em cima da imagem. Consulte o manual para as outras opções.</p>

<p>Seu arquivo pode ser gif, GIF, ..</p>

<p>Em caso de gifs animados, dê uma lida no manual. Existem alguns parâmetros adicionais para otimização de animações.</p>

<h3>Várias imagens de uma vez só</h3>

<p>Para rodar os comandos acima em várias imagens, dentro de vários diretórios, use a opção <strong>-exec</strong> do comando <strong>find</strong></p>

<p><code>find -name '*.png' -exec optipng {} \;</code></p>

<p><strong>-name</strong> para buscar por nome dos arquivos</p>

<p><strong>*.png</strong> irá buscar por arquivos com a extensão .png. Não esqueça das aspas.</p>

<p>Após o <strong>-exec</strong> adicione o comando que você quer executar para todas as ocorrências que serão encontradas.</p>

<p><strong>{}</strong> As chaves representam as ocorrências encontradas.</p>

<p>Feche com <strong>\;</strong></p>

<p>Antes de sair executando essa combinação, teste com um <em>ls -l</em> no lugar do comando. Assim você verá o que o <strong>find</strong> vai retornar. E claro, faço um backup das imagens em outra pasta para evitar maiores problemas.</p>

<h3>man</h3>

<p>Todas as ferramentas acima possuem um manual bem completo e fácil de compreender. Basta digitar <strong>man</strong> e o nome da ferramenta para acessar.</p>

<p>É isso por hoje pessoal! Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quer Estudar Uma Coisa Nova? Docker Te Ajuda!]]></title>
    <link href="http://flaviosilveira.com/2019/quer-estudar-uma-coisa-nova-docker-te-ajuda"/>
    <updated>2019-01-25T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2019/quer-estudar-uma-coisa-nova-docker-te-ajuda</id>
    <content type="html"><![CDATA[<p>Sempre que vamos estudar algo em tecnologia, em programação temos a complexidade do ambiente para resolver. Para um simples <strong>Hello World</strong> precisamos de um ambiente e a complexidade da criação dele pode desanimar os iniciantes (Por isso o JavaScript vem a ser execelente para os iniciantes!).</p>

<p>Mas para ajudar com isso temos os containers e uma ferramenta excelente para trabalhar com eles, o Docker. Diferente de uma máquina virtual, o container vai abranger apenas o que é necessário para rodar sua aplicação, sem precisar de um SO completo.</p>

<p>Vamos dizer então que você quer estudar algo diferente, um banco de dados de grafos e vamos entender como o Docker vai te ajudar com isso.</p>

<!--more-->


<h2>Pesquise</h2>

<p>Então até aqui já temos alguns nomes que podem ser novos para alguns.</p>

<h3>Docker</h3>

<p>Se você não conhece docker, dê uma buscada sobre. É uma ferramenta que pode mudar sua maneira de pensar em ambientes, arquiteturas e até sua maneira de desenvolver.</p>

<h3>Banco de dados de Grafos</h3>

<p>Outro ponto são bancos de dados de Grafos. Pesquise, veja suas aplicações, leia os conceitos. Busque pela solução do problema do caminho mínimo, do caixeiro viajante e outros similares.</p>

<h2>Neo4J</h2>

<p>O Neo4J se tornou um bancos de dados de grafos muito conhecido. Pode ser pela sua interface gráfica ou pelo seu tutorial passo a passo que te mostra algumas coisas legais de entender com grafos.</p>

<p>Ele não é o foco desse artigo mas espero que traga algo para bater na cabeça de vocês.</p>

<h2>O Docker te ajudando a estudar qualquer coisa</h2>

<p>Então vamos dizer que você escolheu que quer estudar grafos e chegou a conclusão que o Neo4J é bom para iniciar. Vamos ver como o docker vai te ajudar nisso.</p>

<p>Massssss&hellip;&hellip; Esse é um exemplo, o que quero mostrar é a facilidade que ele traz seja lá o que você quer estudar. Go, Java, NodeJS, PhantomJS, ferramentas, bancos de dados e outras tantas coisas. Siga os passos que vou descrever abaixo e você encontrará seu caminho.</p>

<h2>Dockerhub</h2>

<p>O Docker funciona com imagens. Uma imagem é um arquivo que contém todas (ou quase todas) as instruções para a rodar a aplicação que você precisa.</p>

<p>O <a href="https://hub.docker.com/">Dockerhub</a> é um repositório dessas imagens, e lá você pode procurar pelo o que você precisa.</p>

<p>Repare que você encontrará imagens oficiais, produzidas pelas empresas dos softwares e imagens criados por outros usuários. As oficiais, geralmente, vem com uma extensa documentação que são de grande ajuda para fazer tudo rodar certinho. Mas, um usuário pode ter tido um insight legal e acrescentado ou facilitado ainda mais o processo, então vale ficar de olho nos dois.</p>

<p>Para um futuro, vale você ver como subir suas imagens</p>

<h2>Subindo um Neo4J</h2>

<p>No Dockerhub procure por Neo4J.</p>

<p>Nos resultados da pesquisa você deve chegar na imagem oficial que está no seguinte endereço <a href="https://hub.docker.com/_/neo4j">https://hub.docker.com/_/neo4j</a>.</p>

<p>Dentrp desse repositório oficial do Neo4J você tem as versões, uma explicação do que é o Neo4J, como usar, documentacão e licença.</p>

<p>Em <strong><em>como usar essa imagem</em></strong>, você vê o comando <strong>docker run</strong> para rodar a aplicação.</p>

<p><strong><strong><em> Sim!! Você já deve ter o docker instalado em sua máquina antes de seguir em diante. Não será difícil achar tutoriais de como fazer isso par aseu sistema operacional internet a fora.</em></strong></strong></p>

<p>Vamos executar:</p>

<pre><code>docker run --publish=7474:7474 --publish=7687:7687 --volume=$HOME/neo4j/data:/data neo4j
</code></pre>

<p>Explicando esse comando temos:</p>

<ul>
<li>&ndash;publish está expondo sua porta 7474 e encaminhando ela para a porta 7474 do container.</li>
<li>O mesmo acontece com a porta 7687.</li>
<li>&ndash;volume é um caminho na sua máquina que será compatilhado com o container. Ele armazenará as mudanças de dados que você fizer, e quando você erguer novamente esse container suas alterações estarão lá.</li>
<li>Neo4J no final é o nome da imagem.</li>
</ul>


<p>A instrução &ndash;publish pode ser abreviado para -p e a instrução &ndash;volume para -v.
Você pode tirar o sinal de igual, manter, tanto faz.</p>

<p>Eu uso como abaixo:</p>

<pre><code>docker run -p 7474:7474 -p 7687:7687 -v $HOME/neo4j/data:/data neo4j
</code></pre>

<p>Essa é a saída que começa a aparecer aqui:</p>

<pre><code>Unable to find image 'neo4j:latest' locally
latest: Pulling from library/neo4j
cd784148e348: Downloading [========================================&gt;          ]  1.785MB/2.207MB
35920a071f91: Download complete 
1a5149a464dd: Downloading [=&gt;                                                 ]  1.621MB/54.87MB
15bb04bfc35a: Waiting 
...
</code></pre>

<ul>
<li>O Docker viu que eu não tinha a imagem, então foi buscar o caminho dela para fazer o download.</li>
<li>Layers, é a maneira que o docker usa para fazer o download das imagens.</li>
</ul>


<p>Na sequência disso ele vai subir a aplicação, até te dizer o seguinte:</p>

<pre><code>....
INFO  ======== Neo4j 3.5.2 ========
INFO  Starting...
INFO  Bolt enabled on 0.0.0.0:7687.
INFO  Started.
INFO  Remote interface available at http://localhost:7474/
</code></pre>

<p>Acesse conforme a saída sugere o endereço <a href="http://localhost:7474">http://localhost:7474</a> e você está na interface do Neo4J.</p>

<p>Viu como é fácil?</p>

<h2>Teste com outras ferramentas / tecnologias</h2>

<p>Acredito que não houve nenhuma dor em seguir os passos acima. É muito simples!</p>

<p>Buscar no dockerhub a tecnologia, dar uma lida em como a imagem se comporta e executar um docker run.</p>

<p>Teste com outras ferramentas, bancos de dados, sistemas, frameworks e se apaixone pelo docker assim como eu.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Como Foi 2018 E O Que Você Pode Esperar De Mim Para 2019]]></title>
    <link href="http://flaviosilveira.com/2019/como-foi-2018-e-o-que-voce-pode-esperar-de-mim-para-2019"/>
    <updated>2019-01-08T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2019/como-foi-2018-e-o-que-voce-pode-esperar-de-mim-para-2019</id>
    <content type="html"><![CDATA[<p>Em minha carreira, graças a excelentes mestres e amigos no meu caminho (cito alguns no final), eu acabei evoluindo e subindo de cargo muito rapidamente. Em poucos anos como desenvolvedor eu fui promovido para Analista e assim se seguiu para Líder de desenvolvimento e chegando até Gerente de TI.</p>

<p>Em uma dessas promoções eu cheguei a pedir demissão, pois queria me preparar melhor antes de liderar ou dar instruções para um time. Mas depois aceitei os desafios.</p>

<p>Nesses períodos eu acabei colocando a mão em código muito menos do que eu esperava. Sempre senti falta, fazia uma coisinha aqui - ali, mas tinha outras responsabilidades. E ressalto que nunca deixei de buscar sempre fazer um grande trabalho independente da posição.</p>

<p>Em 2018 muitas coisas estavam acontecendo, minha filha estava crescendo, problemas de saúde do lado da família da minha esposa e o início e crescimento de uma insatisfação no trabalho da época. Isso somado a excelentes conversas com <a href="https://twitter.com/mhgontijo">Matheus Gontijo</a>, me levaram a pedir demissão e partir para um trabalho de casa, remoto, fora do Brasil.</p>

<!--more-->


<p>Esse passo me fez ver minha posição no mercado. Excelentes empresas me chamaram para conversar e acabei conhecendo muita gente legal. Mas acabei recusando todas, queria mesmo voltar a programar e com o dólar em alta eu poderia trabalhar menos horas por dia e ganhar mais, mesmo com o pagamento dos impostos. Trabalhando menos horas por dia poderia me dedicar a minha filha, família e outros projetos (Palestrei sobre isso em 2018, Trabahe menos, Ganhe mais. Vou compartilhar em breve aqui esse conteúdo).</p>

<h2>Então resumo de 2018</h2>

<p>Larguei minha posição de Gerente para voltar a programar, algo que me fazia falta, que eu amo fazer. Trabalhando de casa, ganhando mais do que como Gerente e trabalhando 5 horas por dia. Pude passar mais tempo com minha família e filha.</p>

<p>Trabalhando menos horas por dia, dediquei o restante do tempo em vários cursos: finanças, ações na bolsa, fundos de investimento e claro desenvolvimento, programação e tecnologia.</p>

<p>Voltei a Meditar, fazer Exercícios, ler e tocar guitarra.</p>

<p>Iniciei também alguns projetos como um ECommerce e meu livro.</p>

<h2>2019</h2>

<p>Nessa mesma pegada quero iniciar e continuar esse ano de 2019.
Então segue aqui o que você pode esperar de mim para esse ano:</p>

<h3>Pessoal</h3>

<p>_ Manter o trabalho de 5 horas por dia, remoto.</p>

<p>_ Usar parte do restante do tempo e aproveitar que estou em casa para poder me alimentar melhor, meditar e fazer exercícios.</p>

<p>_ Colocar no ar o ECommerce que estou trabalhando com outros sócios.</p>

<p>_ Ler pelo menos 25 livros nesse ano (Me acompanhe no <a href="https://www.goodreads.com/">GoodReads</a>).</p>

<h3>Geração de Conteúdo</h3>

<h4>Meu livro</h4>

<p>Estou trabalhando na edição do meu livro chamado PHP Mentors - Advices from PHP Experts around the world. Será uma coleção de respostas de grandes nomes de PHP do mundo e do Brasil. Já contactei 200 desenvolvedores e líderes PHP pelo Mundo!</p>

<p>O primeiro lançamento deve acontecer em Junho e essa primeira versão será em inglês. Mais informações em breve ou se quiser já vai acompanhando aqui <a href="https://leanpub.com/php-mentors">https://leanpub.com/php-mentors</a>.</p>

<h4>Screencasts e vídeos</h4>

<p>Código, vida, Tecnologia e música. Estou preparando a gravação de Screencasts e vídeos que estarão no youtube. A ideia é programar, mostrar tecnologias e trazer alguns amigos para esses vídeos para o mesmo. Serão vídeos de aproximadamente 15 minutos, divertidos e com mão na massa.</p>

<p>Um plus é que também vou colocar alguns vídeos meus tocando algumas músicas de Metal Progressivo para quem quiser ver.</p>

<h4>Blog</h4>

<p>Esse blog vai voltar a ativa (de verdade), com posts para divulgar os projetos acima e também com posts técnicos. A série <strong>**4 Drops of life</strong> onde trago alguns hackings e coisas do meu dia a dia também volta.</p>

<h2>Me cobrem</h2>

<p>É isso, bastante coisa, mas tudo já planejado e com dedicação garantida.</p>

<p>Me cobrem!</p>

<p>Vou mandando as novidades por aqui e através do meu Twitter (<a href="https://twitter.com/flaviosilveira">https://twitter.com/flaviosilveira</a>).</p>

<p>E seu ano? Como será?</p>

<h3>PS</h3>

<p>Quero citar aqui os amigos e mestres mais importantes para mim até esse ponto na minha carreira: Mozart Petter (<a href="https://twitter.com/mokkunsis">https://twitter.com/mokkunsis</a>), Fábio Tomio (<a href="https://twitter.com/fabiotomio">https://twitter.com/fabiotomio</a>), Cristiano Burg (<a href="https://twitter.com/crburg">https://twitter.com/crburg</a>), Peterson Grazek (<a href="https://twitter.com/pegrazek">https://twitter.com/pegrazek</a>), Matheus Gontijo (<a href="https://twitter.com/mhgontijo">https://twitter.com/mhgontijo</a>). Devo muito para vocês! Gratidão Eterna!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Criando Seu Container Com Dockerfile]]></title>
    <link href="http://flaviosilveira.com/2017/criando-seu-container-com-dockerfile/"/>
    <updated>2017-02-12T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2017/criando-seu-container-com-dockerfile</id>
    <content type="html"><![CDATA[<p>Foi uma longa jornada até criarmos nosso container da maneira que queríamos <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-1/">flaviosilveira.com/2017/criando-seu-container-nginx-php-1/</a> e <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2/">flaviosilveira.com/2017/criando-seu-container-nginx-php-2/</a>. Ainda assim temos alguns pontos chatos como o de ter de iniciar o Nginx e o PHP-FPM Manualmente.</p>

<p>Felizmente há uma maneira mais simples de montarmos nosso container e ainda fugindo do trabalho manual. Vamos usar Dockerfile!</p>

<p>Dockerfile é um arquivo onde colocamos tudo o que precisamos para nosso container. De qual container ele se origina, o que você quer instalar, que serviços quer rodar.</p>

<p>Se você está acompanhando a série de artigos sobre docker, basicamente vamos traduzir o que fizemos nos dois artigos anteriores para um Dockerfile.</p>

<p>No decorrer deste artigo vou me referir aos 2 anteriores praticamente o tempo todo. Caso você não os tenha lido, pode ficar um pouco fora de contexto para você, mas nada que vá comprometer o entendimento final.</p>

<!--more-->


<h3>Preparação</h3>

<p>Crie uma pasta chamada <em>docker-test</em>, e dentro dela crie um arquivo chamado <em>Dockerfile</em>. Com a inicial maiúscula e sem extensão.</p>

<p>Isso é tudo que vamos precisar.</p>

<h3>Container de origem</h3>

<p>No começo da parte 1 do artigo falamos sobre de qual container partiríamos. Entre Ubuntu e Debian, ficamos com o Debian.</p>

<p>Para dizer isso para o Dockerfile, usamos <strong>FROM</strong></p>

<pre><code>FROM debian
</code></pre>

<p>Com essa diretiva, estamos partindo da última imagem do debian presente no DockerHub.</p>

<h3>Assine sua imagem</h3>

<p>Use <em>MAINTENER</em> para assinar sua imagem, dizer aos outros quem é o mantenedor dela.
No meu caso:</p>

<pre><code>MAINTAINER Flavio Silveira
</code></pre>

<h3>Atualização e instalações</h3>

<p>Passamos algum tempo atualizando o sistema e em seguida instalando o NGinx e o PHP-FPM. Fizemos isso de fora do container usando o comando <em>docker exec</em>.</p>

<p>No Dockerfile usamos RUN para criar o ambiente da nossa imagem</p>

<pre><code>RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get install -y php5-fpm
</code></pre>

<p>Essas 3 linhas resumem muito do trabalho que foi feito na parte 1 do artigo. Elas indicam respectivamente que queremos atualizar o sistema operacional e em seguida instalar o NGinx e o php5-fpm. Simples assim!</p>

<h3>Configurações</h3>

<p>Para configurar nosso container, entramos nele com o comando <em>docker attach</em> e criamos e alteramos o arquivo <em>/etc/nginx/sites-available/default</em>. Fizemos um arquivo bem enxuto funcionando na porta <em>80</em> e apontando para <em>/var/www/app</em>.</p>

<p>Copie o trabalho que fizemos com o arquivo default dentro do container para um arquivo local, dentro de nossa pasta <em>docker-test</em>, chame ele de <em>default</em>.</p>

<p>Agora vamos dizer para o Dockerfile que queremos copiar esse arquivo para a configuração do Nginx.</p>

<pre><code>COPY default /etc/nginx/sites-available/default
</code></pre>

<p>O primeiro parâmetro é o arquivo em nossa máquina, e o segundo é o lugar que ele vai parar em nossa imagem.</p>

<p>Os passos de criar a pasta app, não serão necessários. Você vai ver como o container vai se virar com isso sem trazer a dor de cabeça para você.</p>

<h3>Fechando sua imagem</h3>

<p>Na parte 2 do artigo anterior criamos a imagem a partir do container que estavamos rodando. Infelizmente tinhamos de iniciar o NGinx e o PHP-FPM manualmente após fazer download da imagem para fazer as coisas acontecerem.</p>

<p>Aqui no Dockerfile vamos resolver esse problema.</p>

<p>Uma vez que nosso ambiente foi preparado com os comandos anteriores, agora vamos usar <em>CMD</em> para dizer como nosso container vai rodar.</p>

<pre><code>CMD service nginx start &amp;&amp; service php5-fpm start &amp;&amp; /bin/bash
</code></pre>

<p>Repare que diferente da diretiva <em>RUN</em>, com <em>CMD</em> concatenamos os comandos usando <em>&amp;&amp;</em>. Precisamos disso pois só podemos ter um <em>CMD</em> no Dockerfile.</p>

<p>Aqui respectivamente iniciarmos o Nginx, em seguida o PHP-FPM e executamos <em>/bin/bash</em> para que o container fique de pé quando iniciado.</p>

<p>Caso a gente não use esse <em>/bin/bash</em> aqui, teremos que passar ele quando rodarmos a imagem com <em>docker run</em>.</p>

<h3>Nosso Dockerfile</h3>

<p>É isso! Já temos tudo o que precisamos no nosso <em>Dockerfile</em>.
Vejam como ficou:</p>

<pre><code>FROM debian

MAINTAINER Flavio Silveira

RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get install -y php5-fpm

COPY default /etc/nginx/sites-available/default

CMD service nginx start &amp;&amp; service php5-fpm start &amp;&amp; /bin/bash
</code></pre>

<h3>Construindo a imagem</h3>

<p>Para construir a imagem a partir do Dockerfile vamos executar o comando docker build.</p>

<pre><code>docker build -t flaviosilveira/php-nginx-2 .
</code></pre>

<p>Usamos o parâmetro -t para dar a nossa imagem um apelido, uma tag para que fique mais fácil levantar ela depois. Assim como no artigo anterior, coloque seu nome de usuário do DockerHub na frente da tag da imagem. Isso será necessário na hora do envio da imagem. No meu caso ficou <em>flaviosilveira/php-nginx-2</em>.</p>

<p>O ponto no final, indica o diretório aonde está o Dockerfile que você criou.</p>

<p>Você verá o docker executar passo a passo do seu Dockerfile em detalhes, acompanhe no seu terminal.</p>

<h3>Checando sua imagem e dando run</h3>

<p>Com o comando <em>docker images</em> você vê sua imagem criada localmente. Vamos testa-lá?</p>

<pre><code>docker run --name usando-dockerfile -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx-2
</code></pre>

<p>Coloquei um nome para meu container de <em>usando-dockerfile</em>.</p>

<p>Passamos a referência de portas, a 8080 de nossa máquina vai bater na 80 do container.</p>

<p>Compartilhei uma pasta local minha <em>~/dev/php</em> para a pasta <em>/var/www/app</em> do container. Tudo que que for feito na pasta local, vai refletir na pasta dentro do container. <em>/var/www/app</em> é o local para onde nosso config do NGinx aponta como diretório raiz.</p>

<p>Faça os testes com seus arquivos PHP e veja em funcionamento.</p>

<p>Caso queira, acesse o container e confirme que seus serviços estão rodando e que o arquivo de configuração do NGinx foi copiado.</p>

<h3>Enviando ao Dockerhub</h3>

<p>Para enviar a imagem para o DockerHub, vamos fazer o mesmo processo do artigo anterior.</p>

<pre><code>docker login
</code></pre>

<p>Caso não tenha usuário no DockerHub, não esqueça de criar antes.</p>

<p>E para enviar a imagem</p>

<pre><code>docker push flaviosilveira/php-nginx-2
</code></pre>

<p>Use com a tag que deu para sua imagem, com seu nome de usuário.</p>

<p>É isso! Acesse o DockerHub para conferir.</p>

<h3>Testando</h3>

<p>Seguindo o mesmo que fizemos no final do último artigo vamos testar.</p>

<p>Antes de testar, vamos eliminar tudo que temos localmente, parar o container e remover a imagem.</p>

<pre><code>docker stop usando-dockerfile
docker rm usando-dockerfile
docker rmi flaviosilveira/php-nginx-2
</code></pre>

<p>Agora executamos o mesmo run que fizemos acima.</p>

<pre><code>docker run --name usando-dockerfile -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx-2
</code></pre>

<p>A imagem não será encontrada localmente e será feito download dela diretamente do DockerHub.</p>

<p>Veja seu container rodando:</p>

<pre><code>docker ps
</code></pre>

<p>Viram como foi muito mais fácil usar o Dockerfile para criar nosso container? Por hoje é isso!</p>

<p>Grande abraço e até a próxima.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Criando Seu Container NGinx + PHP (Parte 2)]]></title>
    <link href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2/"/>
    <updated>2017-01-14T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2</id>
    <content type="html"><![CDATA[<p>No final da <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-1">parte 1 desse artigo</a>, onde montamos um container com Debian, NGinx e PHP, nos deparamos com o seguinte: Se pararmos nosso container e precisar novamente de NGinx + PHP, teremos que partir do zero.</p>

<p>Para evitar isso, vamos criar nossa própria imagem, uma imagem que vai guardar o que fizemos até agora.</p>

<!--more-->


<h3>Saia do container</h3>

<p>Primeiro vamos sair de nosso container com <strong><em>ctrl+p</em></strong> e em seguida <strong><em>ctrl+q</em></strong>.<br/><strong><em>Dica:</em></strong> Não precisa soltar o ctrl.</p>

<h3>Conta no DockerHub</h3>

<p>Vá até o DockerHub <a href="https://hub.docker.com/">https://hub.docker.com</a> e crie sua conta.</p>

<p>Após isso volte para o terminal e faço o comando de login</p>

<pre><code>docker login
</code></pre>

<p>Irá pedir seu usuário e senha e feito!</p>

<h3>Criando Imagem</h3>

<p>Para criar sua imagem, você vai precisar do <strong><em>ID</em></strong> do seu container, use <strong><em>docker ps</em></strong> para consultar. A primeira coluna vai te mostrar seu <strong><em>CONTAINER ID</em></strong>.</p>

<p>Em seguida, execute o commit com o comando abaixo:</p>

<pre><code>docker commit id-do-seu-container flaviosilveira/php-nginx
</code></pre>

<p>Substitua no comando acima <strong><em>id-do-seu-container</em></strong> pelo id mostrado em <strong><em>docker ps</em></strong>.</p>

<p>Fora o id, colocamos o nome que desejamos para nossa imagem. Escolhi php-nginx.</p>

<p>Repare que coloquei meu nome de usuário do DockerHub na frente do nome que quero para a imagem. Isso será necessário na hora do envio para o DockerHub.</p>

<p>O comando vai te retornar um hash SHA-256.</p>

<p>Confira sua imagem criada</p>

<pre><code>docker images
</code></pre>

<p>Sua imagem deve estar no topo dessa lista.</p>

<h3>Usando sua imagem localmente</h3>

<p>Uma vez que vemos a imagem no comando <strong><em>docker images</em></strong>, você já pode usar ela localmente.
<strong><em>ATENÇÃO:</em></strong> Altere o meu nome de usuário abaixo pelo seu.</p>

<pre><code>docker run --name usando-imagem -itd -p 8080:80 flaviosilveira/php-nginx
</code></pre>

<p>Pontos de atenção:</p>

<ul>
<li>Como nossa imagem é baseada na do Debian, rodamos ela de maneira igual. Compare o comando run executado aqui com o da parte 1 desse artigo.</li>
<li>Coloquei a porta 8080 do nosso host para apontar para a 80 do container (-p 8080:80), para não conflitar com a porta 80 do outro container (-p 80:80).</li>
</ul>


<p>Outra coisa. O serviço do NGinx e do PHP5-FPM estão parados!</p>

<p>Você precisa iniciar eles para ver as coisas funcionando.</p>

<pre><code>docker exec minha-imagem service nginx start
docker exec minha-imagem service php5-fpm start
</code></pre>

<p>Agora confira o resultado em <strong><em>localhost:8080</em></strong>.</p>

<h3>Enviando sua imagem para o DockerHub</h3>

<p>Já vimos em outros artigos o comando <strong><em>docker pull</em></strong> que serve para fazermos download de imagens para nossa máquina. Por padrão ele busca imagens do DockerHub, repositório padrão do docker.</p>

<p>Agora para enviarmos imagens para ele, temos o <strong><em>push</em></strong></p>

<pre><code>docker push flaviosilveira/php-nginx
</code></pre>

<h3>Testando</h3>

<p>Antes de testar, vamos eliminar tudo que temos localmente. Parar o container e remover a imagem.</p>

<pre><code>docker stop usando-imagem
docker rm usando-imagem
docker rmi flaviosilveira/php-nginx
</code></pre>

<p>Agora basta tentar executar o mesmo run que fizemos acima.</p>

<pre><code>docker run --name usando-dockerhub -itd -p 8080:80 flaviosilveira/php-nginx
</code></pre>

<p>A imagem não será encontrada localmente e será feito download dela diretamente do docker hub.</p>

<p>Veja seu container rodando</p>

<pre><code>docker ps
</code></pre>

<p>Ou dê start no NGinx e no PHP-FPM e acesse no seu navegador na porta 8080 como colocamos acima.</p>

<h3>Compartilhando seus arquivos php com o container</h3>

<p>Para compartilhar seus arquivos locais de PHP com o container, use o parâmetro de volume, como fizemos no artigo de <a href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/">docker com PHP Built in</a>.</p>

<pre><code>docker run --name usando-dockerhub -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx
</code></pre>

<p>No parâmetro -v, você coloca o caminho da sua pasta local e separado por : (dois pontos) temos a pasta root que definimos no nosso NGinx.</p>

<p>Acesse o navegador para constatar.</p>

<h3>Resumo e Próximos passos?</h3>

<p>Nesse artigo dividido em duas partes fizemos bastante coisa:
<br/>Usamos uma imagem debian, instalamos NGinx e PHP de fora do container com <strong><em>exec</em></strong> e depois entramos nele para configurar as coisas.</p>

<p>Criamos um login no dockerHub, criamos uma imagem nossa e agora ela está disponível para quem precisar.</p>

<p>Mas a maneira como fizemos não deixa claro de que imagem partimos ou ainda caso a gente desista de usar Debian e queira usar CentOS, você vai ter que novamente partir do zero dessa maneira que fizemos.</p>

<p>Nossos próximos passos são aprender um pouco sobre tags e criar nossa imagem usando DockerFile, que também vai nos ajudar a parar com a chatisse de ter que iniciar o php e o NGinx manualmente.</p>

<p>Vamos para um post sobre isso?</p>

<p>Até lá! Grande Abraço!</p>
]]></content>
  </entry>
  
</feed>
