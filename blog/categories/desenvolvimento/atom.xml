<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Desenvolvimento | Flávio Silveira]]></title>
  <link href="http://flaviosilveira.com/blog/categories/desenvolvimento/atom.xml" rel="self"/>
  <link href="http://flaviosilveira.com/"/>
  <updated>2016-11-08T00:23:35+00:00</updated>
  <id>http://flaviosilveira.com/</id>
  <author>
    <name><![CDATA[Flávio Silveira]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Microserviços]]></title>
    <link href="http://flaviosilveira.com/2016/microservicos/"/>
    <updated>2016-11-07T08:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/microservicos</id>
    <content type="html"><![CDATA[<p>Muito anda se falando sobre microserviços e trago para vocês minha experiência de como começamos a trabalhar dessa forma aqui na <a href="https://www.lojaskd.com.br">LojasKD</a>.</p>

<p>Assim como meu post anterior sobre <a href="http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce/">Ansible e automação</a>, esse assunto também faz parte de uma palestra que apresentei durante 2016, um dos meus grandes orgulhos desse ano que encerro com esse post.</p>

<h3>Microserviços - O que é?</h3>

<p>Para falar sobre microserviços eu sempre empresto a frase do <a href="https://twitter.com/tiagodolphine">@tiagodolphine</a>: &ldquo;O menor possível, porém grande o suficiente para representar seu domínio&rdquo;.</p>

<!--more-->


<p>Pequenas aplicações que representem seus domínios. Parece fácil ah?
Mas a linha para que isso se torne um <strong>macroserviço</strong> é tênue. Se você descuidar da organização dos seus serviços eles podem começar a dar mais trabalho do que você gostaria.</p>

<h3>Seus problemas não acabaram</h3>

<p>Não existe solução perfeita, tudo tem seu uso ideal, seu lado bom e seu lado ruim.</p>

<p>Microserviços não são uma bala de prata que vai resolver todos os problemas de seus projetos. Assim como você escolhe uma linguagem para desenvolver um projeto, qual banco de dados vai usar e etc, o mesmo deve servir para sua arquitetura.</p>

<p><strong>Não vá de microserviços simplesmente pelo modismo!</strong></p>

<p>Aliás, microserviços pode ser comparado ao que acontecia com APIs em SOAP (Simple Object Access Protocol) com seus WSDLs para lá e para cá, que tem seus primeiros registros de uso no fim dos anos 90. Tecnologia tem muito disso, coisas que voltam com nomes diferentes ou um buzz que surge com coisas que já fazemos.</p>

<p>Acompanhem comigo os prós e contras de uma arquitetura monolítica versus uma de microserviços.</p>

<h3>Monolítico</h3>

<p>Há não tantos anos atrás, na hora de iniciar nossos projetos era certo que eles seriam de uma forma única. Como estamos falando da KD aqui, vamos pegar o exemplo de ECommerce.</p>

<p>Um banco de dados, uma aplicação MVC em cima de uma linguagem. Um controller para a Vitrine, outro para o Carrinho, outro para o Checkout. Tudo em um lugar só.</p>

<p>Mas então quando seu serviço cai? Tudo cai, tudo fica fora. <strong>-1 aqui para o monolítico</strong>. Mas, na hora de colocar isso em produção? Demais! Tudo em um só lugar, um único deploy. <strong>+1 para o monolítico</strong>.</p>

<p>Se uma das partes do seu sistema ficava lento, grande chance de ele ficar lento por inteiro. E a parte que está deixando lento, que digamos seja lá na visualização de produtos, está impedindo que pessoas fechem suas compras. <strong>-1 para o monolítico</strong>.</p>

<p>Vamos monitorar para que não caia novamente? Vamos ter que monitorar uma única aplicação, Ótimo! <strong>+1 para o monolítico</strong>.</p>

<p>Achar desenvolvedores para um projeto com uma linguagem só é um outro ponto positivo aqui e também o conhecimento em cima de como servir uma única aplicação. <strong>+2 para o monolítico</strong>. Mas a curva de aprendizagem em cima de regras de negócio que estão todas juntas e misturadas podem complicar. <strong>-1 para o monolítico</strong>.</p>

<h3>Os Microserviços</h3>

<p>Em microserviços não vamos pensar como uma coisa só, vamos pensar como várias pequenas partes para formar um objetivo comum. Nosso Carrinho, nossa Vitrine, nosso Checkout que estavam todos juntos, aqui se separam em pequenas aplicações cada uma com sua função.</p>

<p>Se um dos nossos serviços caírem, outros serviços continuam funcionando e nosso ECommerce não fica totalmente fora. <strong>+1 para os microserviços</strong>.</p>

<p>Mas fazer deploy de tudo, várias aplicações. E se uma depender de outra em determinada funcionalidade? E se&hellip; É, a orquestração de entregas com microserviços pode não ser simples. <strong>-1 para os microserviços</strong>.</p>

<p>Lentidão em um dos serviços? Não deve afetar o restante. <strong>+1 para os microserviços</strong>. Ainda você pode escalar as funcionalidades de uma maneira mais flexível. Exemplo: Você tem muito mais acessos na vitrine do que no carrinho? Coloque mais máquinas para servir sua parte de vitrines, deixe a parte do carrinho com menos máquinas. É uma maneira de otimizar custos usando microserviços.</p>

<p>Agora, monitorar várias aplicações, ter uma arquitetura maior para cuidar. <strong>-1 para os microserviços</strong>.</p>

<h3>Tecnologias Agnósticas</h3>

<p>Dei a entender em um dos pontos acima que com microserviços teremos várias linguagens. Isso não é regra, claro! Mas com uma arquitetura em microserviços fica muito mais fácil você experimentar uma nova linguagem para solucionar algum problema. Se não der certo, tudo bem! O Serviço está pequeno o suficiente para você rescrever ele em uma linguagem do seu domínio em pouco tempo.</p>

<p>Coloco isso como dois pontos positivos dos microserviços: Você poder experimentar novas linguagens, poder colocar junto linguagens que não acreditam umas nas outras, descobrir novos conceitos de programação de maneira fácil sem complicar todo um negócio. E a facilidade em reescrever se for necessário. É pequeno, é rápido reescrever. <strong>+2 para os microserviços</strong>.</p>

<p>Mas, na hora de contratar pessoal para mexer com várias linguagens você pode ter um problema. <strong>-1 para os microserviços</strong>.</p>

<h3>Quem ganhou?</h3>

<p>Se você está fazendo a matemática dos pontos acima, você está perdendo. Veja o que se aplica melhor para sua necessidade e o que você pode ganhar com cada uma. Novamente, não há melhor ou pior, são soluções distintas.</p>

<p>O que você usaria para provar um conceito de uma ideia para startup? Para um hot site? Um portal de notícias? Um site institucional? Um sistema administrativo?</p>

<p>Recomendo aqui a audição do Episódio #1 do Hipsters ponto tech, <a href="http://hipsters.tech/tecnologias-no-nubank-hipsters-01/">http://hipsters.tech/tecnologias-no-nubank-hipsters-01/</a> onde o pessoal do NuBank comenta sobre a escolha de microserviços desde o início, e suposições do que poderia ter acontecido se não tivessem ido por esse caminho.</p>

<h3>Comunicação entre microserviços</h3>

<p>Várias aplicações, várias linguagens, como uma vai conversar com a outra?</p>

<p>Estamos em 2016 e para comunicar linguagens diferentes hoje temos padrões como REST, JSON que são simples de trabalhar e estão presentes em todo o lugar. Diferente dos antigos e trabalhosos XMLs com WSDLs que infelizmente ainda encontramos por aí.</p>

<h3>Bancos de dados Agnósticos</h3>

<p>Muito do que falamos acima para aplicações e linguagens, podem vir de encontro também ao pensar em banco de dados. Porque um banco de dados monolítico? Se ele ficar comprometido pode comprometer todo seu negócio.</p>

<p>Você poder experimentar bancos de dados diferentes em busca de soluções diferentes, performances de cada um e etc. Um banco de dados para produtos, outro banco de dados para pedidos e assim por diante.</p>

<p>Ah, mas como vou tirar relatórios para os meus diretores com várias bases? Como vou unir os dados de uma base com a outra? A resposta aqui pode ser BI. Business Inteligence. Una as informações que sua empresa precisa para seus KPIs e OKRs em um único ponto, onde eles possam montar seus relatórios em uma única ferramenta.</p>

<h3>Na KD</h3>

<p>Agora que já comentamos alguns pontos gerais de microserviços e estruturas monolíticas. Segue alguns pontos da nossa experiência com microserviços aqui na LojasKD:</p>

<ul>
<li><p>Os Microserviços chegaram na KD para resolver um problema de software legado. Foi a maneira que encontramos para ir substituindo as funcionalidades de uma grande aplicação monolítica aos poucos, até que não tenhamos mais ela. Estamos nesse rumo.</p></li>
<li><p>Como não tinhamos nenhuma experiência com microserviços, começamos com algo minúsculo. Um serviço que apenas trazia as informações de um pedido quando passado seu ID.</p></li>
<li><p>Começamos a experimentar linguagens e bases de dados diferentes em busca de soluções melhores para problemas conhecidos.</p></li>
<li><p>Já erramos e tivemos que reescrever microserviços inteiros novamente, mas não levou mais que uma semana.</p></li>
<li><p>Para serviços mais críticos, mantemos em nossa linguagem de maior domínio hoje, PHP.</p></li>
<li><p>Sofremos um pouco com monitoramento. É bastante coisa  para monitorar, disparar alertas e ficar de olho. Custo e trabalho em cima disso são altos.</p></li>
<li><p>A manutenção dos servers não é tão crítica, temos receitas em puppet e dockerfiles que nos ajudam nessa área.</p></li>
<li><p>Os deploys estão automatizados, mas as vezes precisamos fazer uma orquestração verbal para evitar conflitos.</p></li>
<li><p>Nosso time de desenvolvedores trabalham em cima de todos os microserviços e em suas diferentes linguagens. Temos Node, Python, Ruby, Java, GOLang e o já citado PHP. Sofremos um pouquinho na hora de contratar pessoas hoje. Não queremos desenvolvedores que saibam todas essas linguagens, mas o que acontece é que os candidatos acabam assustados com a diversidade.</p></li>
</ul>


<p>-É natural que um desenvolvedor entenda mais de uma linguagem do que de outra e vá guiando o time.</p>

<ul>
<li><p>Não descuide do tamanho dos microserviços. Mantenha uma documentação básica no mínimo.</p></li>
<li><p>Estude sobre API Gateway.</p></li>
</ul>


<p>Espero que minha abordagem para explicar microserviços tenha ajudado.
Mas e vocês, como estão usando microserviços? Ou como estão pretendendo usar?
Dúvidas? Outras ideias? Só comentar.
Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ansible - Desperte a Automação Em Você]]></title>
    <link href="http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce/"/>
    <updated>2016-10-17T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce</id>
    <content type="html"><![CDATA[<p>
Automação vem se tornando um tema essencial em empresas que querem crescer com mais cérebro e menos braço. Aquela tarefa que você repete mais de duas vezes já deve ser pensada em uma maneira de ser automática, concorda?</p>

<p>No universo do desenvolvimento, quantas são as tarefas que repetimos quando se trata de máquinas? Deploys, extração de logs, instalação e configuração de ferramentas, etc. Ansible pode ser a ferramenta que vai te ajudar a automatizar tudo isso.</p>

<!--more-->


<p>Durante esse ano de 2016 apresentei a palestra <strong><em>Automações com Ansible</em></strong> onde o objetivo principal foi uma iniciação ao Ansible. Como usar ele de maneira bem básica e se iniciar na automação. Estrutura de um projeto básico, como criar as primeiras tarefas, passar argumentos, variáveis, e usar includes. Essa vai ser a agenda desse longo post técnico e assim também encerrando as apresentações dessa palestra para dar lugar a outras :-).</p>

<h4>Ansible</h4>

<p>Ansible (<a href="https://www.ansible.com/">https://www.ansible.com/</a>) é uma ferramenta Open Source em Python para automatizar ações em máquinas. Ela é super simples, e esse é sempre um dos meus lemas quando se trata de desenvolvimento e tecnologia. Se está difícil, tem alguma coisa errada. Pare e analise. Tecnologia não é mágica, tem que fazer sentido.</p>

<p>Não vou falar da instalação do Ansible. É fácil você fazer download dele e sair rodando ou ainda usar <strong>yum install</strong> ou <strong>apt-get install</strong>.</p>

<h4>Um projeto básico</h4>

<p>Há várias maneiras de estruturar um projeto ansible. Algumas sugestão com arquiteturas de pastas super elaboradas, onde podem fazer sentido para algumas soluções. Para agora, para começarmos, dois arquivos vão resolver nosso problema.</p>

<pre><code>- projeto.yml
- hosts
</code></pre>

<p>Um arquivo com extensão .yml (yet another markup language) e um arquivo hosts, sem extensão.
No arquivo yml você vai colocar o passo a passo da sua automação. Tecnicamente ele tem o nome de playbook. No arquivo hosts vamos apontar as máquinas onde as tarefas serão executadas.</p>

<h4>Arquivo hosts</h4>

<p>Vamos primeiro configurar as máquinas que serão afetadas pelas nossas tarefas.</p>

<pre><code>#This is the Host File.

[projeto]
192.168.5.6 ansible_ssh_user=user ansible_ssh_pass=pass
</code></pre>

<p>É isso que vocês precisam no arquivo hosts quando falamos de acesso que o ansible vai fazer usando ssh. O IP da máquina, seguido de um usuário e senha. Esse nome em colchetes vai te ajudar a gerenciar as coisas em um futuro, mantenha ele ali.</p>

<p>Vai fazer uso de portas? Acesso a máquinas com chave? Chamar mais de uma máquina?</p>

<pre><code>#This is the Host File.

###################
# Projeto servers #
###################
[projeto-homologacao]
222.222.222.222:2123 ansible_ssh_private_key_file=/.ssh/chave.pem ansible_ssh_pass=pass
123.123.123.123:2123 ansible_ssh_private_key_file=/.ssh/chave.pem ansible_ssh_pass=pass

[projeto-local]
192.168.5.6 ansible_ssh_user=user ansible_ssh_pass=pass
</code></pre>

<p>Para acessar as máquinas usando chaves use <strong>ansible_ssh_private_key_file</strong>. Se seu acesso tem portas diferentes, basta adicionar elas ao final do IP.</p>

<p>Notem que fiz uma separação entre as máquinas de homologação e a máquina local. Essa organização pode te ajudar no futuro a gerenciar essas máquinas e usar isso em suas automações.</p>

<h4>Rodando o Ansible</h4>

<p>Para rodar o ansible o comando é fácil</p>

<pre><code>ansible-playbook -i hosts projeto.yml
</code></pre>

<p>Ansible-playbook é o comando. -i  é o parâmetro que significa inventory, para inventário, onde passaremos nosso arquivo hosts. Por último nosso arquivo de tarefas. Sim! Não temos nenhuma tarefa, já vamos chegar lá.</p>

<p>Caso precise rodar o ansible com mais saidas de log, em um momento para resolver problemas por exemplo, você pode usar -v, de verbose.</p>

<pre><code>ansible-playbook -i hosts projeto.yml -v
ansible-playbook -i hosts projeto.yml -vv
ansible-playbook -i hosts projeto.yml -vvv
ansible-playbook -i hosts projeto.yml -vvvv
</code></pre>

<p>As opções vão até 4 Vs. Onde cada um a mais, te mostra mais detalhes dos comandos e dos erros se houver.</p>

<h4>Criando tasks</h4>

<p>Vamos começar com um exemplo bem simples de tarefa, um hello world por assim dizer.</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
- name: "Vamos dar echo"
  shell: 'echo teste'
</code></pre>

<p>Lembra no nosso arquivo hosts a separação que fizemos com os colchetes? Use o nome que você definiu lá, aqui na opção hosts.</p>

<p>Em seguida criamos uma tarefa com o nome <strong>Vamos dar echo</strong>. E é isso que ela se dispõe a fazer. Rodando o playbook acima, ele vai acessar as máquinas presente no seu host e executar um <strong>echo teste</strong>.</p>

<p>Reparem que usamos o módulo <strong>shell</strong> do ansible para executar o comando. Vamos falar mais disso depois.</p>

<p>Vamos criar uma nova tarefa, agora usando o módulo <strong>script</strong> do ansible. Você deve ir aninhando as suas tarefas uma abaixo da outra como segue:</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
  - name: "Vamos dar echo"
    shell: 'echo teste'

  - name: "Executar um script"
    script: '/bin/usr/meu.sh'
</code></pre>

<p>Adicionamos a tarefa chamada <strong>Executar um script</strong>, que vai executar o .sh presente no caminho passado.</p>

<h4>Módulos</h4>

<p>Ansible tem vários módulos como você pode conferir na documentação em <a href="http://docs.ansible.com/ansible/modules_by_category.html">http://docs.ansible.com/ansible/modules_by_category.html</a>.</p>

<p>Esses módulos vem para te ajudar a criar tarefas das mais diferentes naturezas que você imaginar. Execução de linhas de comando, criação de arquivos, acesso a repositórios de versionamento, filas (rabbit, sqs, kafka), checar acesso a outras redes, instalação de programas, acesso a Amazon, Azure, Google Cloud, etc. Esses exemplos são poucos. Dê uma boa navegada na página acima para conferir a real gama de facilidades que o ansible nos dá.</p>

<p>Retorne os olhos nas tasks que fizemos acima e veja os módulos em ação. Usamos Shell e Script que fazem parte da categoria <strong>Commands Modules</strong> (<a href="http://docs.ansible.com/ansible/list_of_commands_modules.html">http://docs.ansible.com/ansible/list_of_commands_modules.html</a>).</p>

<p>Para efeitos didáticos, não vamos usar em nossos exemplos aqui módulos muito diferentes e ousados. Mas não se limite! A documentação do Ansible é excelente e fácil de compreender e vai te ajudar com toda certeza.</p>

<h4>Argumentos</h4>

<p>Os módulos podem ter argumentos / parâmetros. Alguns são nativos a todos os módulos do Ansible, outros são específicos. Confira a documentação para ir ficando a par disso.</p>

<pre><code>tasks:
  - name: "Ver se existe a pasta do projeto criada"
    shell: 'mkdir projeto'
    args:
      chdir: '/home'
      creates: 'projeto'
</code></pre>

<p>Aqui com <strong>args</strong>. Usamos <strong>chdir</strong> para dizer aonde queremos executar nossa tarefa.
Também usamos <strong>creates</strong>, que nos ajuda checando se o mkdir vai ser necessário mesmo ou não.</p>

<h4>Variáveis</h4>

<p>Podemos e devemos definir variáveis no topo de nossos playbooks para usá-las em nossas tasks.</p>

<pre><code>---
# Projeto
- hosts: "projeto"

vars:
    repo: git@bitbucket.org/flaviosilveira/primeiro-jogo-html5.git
    document_root: /var/www
    releases_folder: releases

- name: "Clone/Update projeto"
  git: 'repo=ssh://{{repo}} dest={{document_root}}/{{releases_folder}} clone=yes update=yes accept_hostkey=yes force=yes'   
</code></pre>

<p>Usamos as variáveis com seus nomes entre chaves duplas <strong>{{nome_da_variavel}}</strong>.</p>

<p>Repare como se compõe o comando para clonar ou atualizar nosso projeto usando o módulo git do ansible. Esse módulo faz clone se o projeto git não existir na máquina ou atualiza se ele já estiver lá.</p>

<h4>Passando variáveis pela linha de comando</h4>

<p>Você consegue passar variáveis através da chamada do ansible, o que pode te dar ainda mais ideas em suas automações.</p>

<pre><code>ansible-playbook -i hosts projeto.yml -e "env=homologacao"
</code></pre>

<p>Com -e, passamos a variável <strong>env</strong> para nosso playbook. De dentro dele, vamos usar {{env}} para resgatar.</p>

<pre><code>---
# Projeto
- hosts: "projeto-{{env}}"
</code></pre>

<p>Lembram na definição de nossos hosts, quando fizemos uma variação com máquinas de homologação e uma máquina local? Aqui está um uso para essa organização, facilitando em você não ter de ficar alterando seus playbooks todo o tempo.</p>

<h4>Salvando saídas de tarefas como variável</h4>

<p>Outra coisa legal é armazenar saídas de tarefas para variáveis e assim poder usá-las posteriormente.</p>

<pre><code>- name: "Contar pastas"
  shell: 'ls | wc -l'
  args:
    chdir: '{{document_root}}/{{releases_folder}}'
  register: to_remove
</code></pre>

<p>Na tarefa acima, usamos um comando Shell para contar um número de pastas.
Estamos usando argumentos para o módulo e também variáveis. Coisas que já vimos acima.</p>

<p>Em seguida registramos a saída desse comando para a variável <strong>count</strong>.
Para usá-la? {{count}}.</p>

<p>As vezes o que você coloca na variável é um objeto. Confira a saída em verbose (-vvvv) caso tenha problemas usando como acima. Talvez você precise de alternativas:</p>

<pre><code>{{count.stdout}} #Saída do ansible
{{count.stdout | int}} #Mesmo que acima, mas convertendo para inteiro
</code></pre>

<h4>Condicionais</h4>

<p>Uma task pode ser executada ou não baseado em uma condional.</p>

<pre><code>- name: "Remove pastas"
  shell: 'ls -t | tail -n $(($(ls | wc -l)-3)) | xargs rm -rf'
  args:
    chdir: '{{document_root}}/{{releases_folder}}'
  when: '{{count.stdout | int}} &gt; 3'
</code></pre>

<p>Reparem na última linha, no <strong>when</strong>. Se a variável nos trouxer um resultado maior que 3, executaremos a tarefa, caso contrário não.</p>

<p>Para curiosidade, esse comando ordena as pastas por data, e deixa apenas as últimas 3, removendo o restante.</p>

<h4>Ignorando erros</h4>

<p>As vezes algumas tarefas nos trarão erros, mas que por algum motivo não precisamos nos preocupar. Para isso, use <strong>ignore_errors</strong>.</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
  - name: "Vamos dar echo"
    shell: 'echo teste'
    args:
       chdir: '{{document_root}}/{{releases_folder}}'
    ignore_errors: true
</code></pre>

<p>Pronto, erros serão ignorados e seu playbook continuará em execução.</p>

<p>Isso pode ser útil também para algum comando que tem uma saída de comando muito grande. O ansible as vezes considera isso como um erro.</p>

<h4>Usando Includes</h4>

<p>Alguma tarefa que vai ser executada em mais de um playbook? Use Includes.
Crie uma pasta chamada <strong>includes</strong> e dentro dela crie um arquivo chamado <strong>outro.yml</strong>.</p>

<p>Dentro do seu arquivo <strong>outro.yml</strong>, você trabalha como se ele fosse uma tarefa normal</p>

<pre><code>---
# Include responsavel pela criacao da pasta

- name: "Ver se existe a pasta do projeto criada"
  shell: 'mkdir projeto'
  args:
    chdir: '/home'
    creates: 'projeto'
</code></pre>

<p>Para usar o include em outros playbooks faça:</p>

<pre><code>tasks:
  - include: 'includes/outro.yml'
</code></pre>

<p>Quer passar variáveis para seus includes?</p>

<pre><code>tasks:
  - include: 'includes/outro.yml variavel=3 variavel2={{document_root}}'
</code></pre>

<p>Reparem que definimos uma variável no momento de chamar o include e para a variável chamada <strong>variavel2</strong>, usamos uma variável que pode ter sido definida no topo de nosso playbook ou ainda que pode ter vindo da saída de uma task.</p>

<h4>That&rsquo;s It</h4>

<p>É isso por hoje pessoal! Cobrimos aqui o bé-a-bá no ansible, criamos tarefas, definimos nossas máquinas afetadas, aprendemos sobre módulos, argumentos, variáveis e includes.</p>

<p>Exercite em sua infraestrutura. Se não tem uma infraestrutura para testar, experimente com máquinas virtuais ou ainda com containers em Docker, tema que viemos discutindo aqui no Blog recentemente (<a href="http://flaviosilveira.com/2016/comece-com-docker/">http://flaviosilveira.com/2016/comece-com-docker/</a>, <a href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/">http://flaviosilveira.com/2016/docker-php7-e-php-built-in/</a>).</p>

<p>Desperte a automação em você! Grande Abraço!
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker, PHP7 E PHP Built In]]></title>
    <link href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/"/>
    <updated>2016-10-10T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/docker-php7-e-php-built-in</id>
    <content type="html"><![CDATA[<p>No artigo anterior (<a href="http://flaviosilveira.com/2016/comece-com-docker/">Comece com Docker!</a>) descrevemos juntos alguns passos iniciais com o Docker. Criamos containers, usamos attached, detached, entramos, saímos, executamos comandos. Se você não está familiarizado a isso, te convido a visitar o artigo.</p>

<p>Sendo repetitivo, meu desejo com esses artigos sobre docker é passar para as pessoas as facilidades que containers nos dão para experimentar tecnologias. Que tal hoje experimentarmos o PHP7? Se você não teve a oportunidade de mexer um pouco com ele o Docker está aqui para facilitar as coisas. E para facilitar ainda mais vamos usar o recurso Built In, presente desde a versão 5.4, que nos traz um servidor web embutido. Assim não vamos precisar instalar nada mais.</p>

<!--more-->


<h3>PHP no DockerHub</h3>

<p>No final do artigo anterior falamos sobre o <a href="https://hub.docker.com/">DockerHUB</a>, repositório oficial de imagens para criarmos nossos containers.</p>

<p>O <a href="https://hub.docker.com/_/php/">PHP tem um reposítorio oficial no Docker hub</a> e é de lá que vamos começar. Nessa página temos várias informações desde o que é PHP até como usar a imagem, contribuir, instalar extensões e etc.</p>

<p>Nos comandos que usamos, fizemos <strong><em>Docker Run</em></strong> que verifica se já temos a imagem em nossa máquina e caso não tenha faz o download dela. Vamos aprender um comando novo.</p>

<pre><code>docker pull php
</code></pre>

<p>Com docker pull vamos fazer apenas o download da imagem, ele não vai iniciar um container para a gente direto como <strong><em>docker run</em></strong> faz, apenas o download.</p>

<p>Nesse comando temos a opção de especificar a versão que queremos do PHP. Não passando nada, vai vir para a gente a última. Exatamente o que estamos querendo aqui certo?</p>

<h3>Subindo Container PHP</h3>

<p>Uma vez que a imagem está em nossa máquina, é hora de rodar o container. Vamos ver em que versão estamos?</p>

<pre><code>docker run php php --version
</code></pre>

<p><strong>Docker run</strong> é nosso comando. <strong>php</strong> é o nome da nossa imagem e em seguida o comando que queremos executar no nosso container, <strong>php &ndash;version</strong>.</p>

<p>Ao final desse comando o container terá subido, executado <strong>php &ndash;version</strong>, mostra uma saída e mata o container. A saída dada para mim na data de hoje foi versão <strong>PHP7.0.11</strong>.</p>

<p>O Container morre, porque o comando que passamos executou e finalizou. Comprovamos isso rodando <strong>docker ps</strong>.</p>

<h3>PHP CLI</h3>

<p>Na mesma pegada, vamos testar o PHP CLI com nosso container. PHP CLI é o php em linha de comando.</p>

<p>Mas antes vamos criar um script php para rodar no CLI. Criei uma pasta chamada <strong>php</strong> no meu diretório de desenvolvimento e dentro dele vou criar um script chamado <strong>spaceship.php</strong>.</p>

<pre><code>&lt;?php

// Testing Spaceship Operator
echo 2 &lt;=&gt; 2; // 0
echo 5 &lt;=&gt; 6; // -1
echo 6 &lt;=&gt; 5; // 1

echo "a" &lt;=&gt; "a"; // 0
echo "a" &lt;=&gt; "b"; // -1
echo "b" &lt;=&gt; "a"; // 1
</code></pre>

<p>O objetivo desse script é simplesmente testarmos o Spaceship, novo operador que veio com o PHP7. Vamos rodar ele em um container?</p>

<pre><code>docker run -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php spaceship.php
</code></pre>

<p><strong>Docker run</strong> é nosso comando. Com <strong>-v</strong> vamos fazer share do nosso diretório da nossa máquina local com um diretório de nosso container. Os dois vão estar espelhados. Com <strong>-w</strong> vamos dizer para nosso container php qual é nosso Working directory, nosso diretório de trabalho. Repare que coloquei o mesmo diretório que em nosso container é equivalente ao diretório em nossa máquina.</p>

<p><strong>php</strong> é o nome da nossa imagem que vai servir de base para nosso container e <strong>php spaceship.php</strong> é nosso comando que vai rodar em nosso working directory.</p>

<p>A saída esperada é <strong>0-110-11</strong>, como nos comentários do script acima.
Já conhecia o Spaceship? Vale uma lida na documentação em <a href="http://php.net/manual/en/migration70.new-features.php">novas features PHP7</a>.</p>

<h3>PHP Built In</h3>

<p>Finalmente, vamos finalizar com o PHP Built In.</p>

<p>Vamos primeiro lembrar como é o comando do PHP Built In. Para consultar o help do PHP Cli podemos fazer</p>

<pre><code>docker run -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php --help
</code></pre>

<p>Com -S maiúsculo, temos o que procuramos:</p>

<pre><code>php -S 127.0.0.1:8080
</code></pre>

<p>Simples não? -S, IP e a porta para acessar.</p>

<p>Dessa vez vou explicar o comando que vamos fazer antes:
<strong>Docker run</strong> que é nosso comando para subir o container. <strong>-p</strong> vai mapear a porta 8080 da nossa máquina para a porta 8080 do container. <strong>-v</strong> como vimos anteriormente vai fazer o share do nosso diretório. <strong>-w</strong> especifica onde vai ser o working directory do container php. <strong>php</strong> é o nome da nossa imagem que vai servir de base para nosso container. E o comando que vamos executar dentro do container será <strong>php -S 0.0.0.0:8080</strong>.</p>

<pre><code>docker run -p 8080:8080 -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php -S 0.0.0.0:8080
</code></pre>

<p>Em meu exemplo eu estou usando uma docker machine que tem um IP <strong>192.168.99.100</strong>, quando passo para o comando do container um IP <strong>0.0.0.0</strong> ele é traduzido para o IP da minha docker machine.</p>

<p>Ao executar o comando, ele vai ficar esperando.</p>

<p>Acesso no navegador o seu IP passando a porta 8080, e acrescente <strong>/spaceship.php</strong>. O mesmo resultado visto anteriormente no terminal, agora está no seu navegador.</p>

<p>Para matar o container basta retornar ao terminal e dar um <strong>CTRL+C</strong>.</p>

<h3>Fechando</h3>

<p>Hoje usamos a imagem do PHP. Para quem nunca havia provado o PHP7, fica a sugestão de fazer esse experimento bem facilmente usando containers e Docker. Aprendemos o comando para simplesmente fazer download de uma imagem e exploramos a imagem do PHP usando CLI e Built In.</p>

<p>Espero que sua cabeça esteja com ideias em cima do que foi passado aqui.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comece Com Docker]]></title>
    <link href="http://flaviosilveira.com/2016/comece-com-docker/"/>
    <updated>2016-10-03T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/comece-com-docker</id>
    <content type="html"><![CDATA[<p>Tenho dois posts envolvendo <a href="https://www.vagrantup.com/">vagrant</a> aqui no blog que ainda são certo sucesso de acessos. <a href="http://flaviosilveira.com/2012/vagrant-facil-e-util">Vagrant Fácil e Útil</a> que dá uma introdução ao Vagrant com um exemplo simples e <a href="http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in/">Vagrant, PuPHPet E PHP Built In</a> que apresenta o PuPHPet como um facilitador para criar ambientes e um experimento com o PHP Built In. O primeiro artigo é de 2012, o segundo de 2013. Passados três anos e vendo a busca disso não diminuir, quero trazer para quem ainda não conhece o <a href="https://www.docker.com/">Docker</a>.</p>

<!--more-->


<h3>Containers VS Virtual Machines</h3>

<p>Muita coisa me anima no Vagrant: ser uma máquina virtual leve, poder deixar minha máquina limpa sem ter que instalar várias coisas, poder trabalhar com várias versões de software com facilidade, se aproximar bastante do ambiente de produção e poder experimentar sem medo.</p>

<p>Não vou entrar aqui na discussão filosófica sobre docker vs vagrant, quero apenas trazer uma alternativa a tudo que eu coloquei acima e, em um futuro, mostrar como o docker pode nos ajudar a experimentar ainda mais novas tecnologias.</p>

<p>Docker trabalha com containers, Vagrant com máquinas virtuais. Qual a diferença se você está começando com tudo isso? Não muita! Você pode pensar no container como uma máquina virtual se você está começando mas tenha em mente que todo o conceito e funcionamento é diferente. Ná prática você vai continuar com um mundo paralelo onde vai poder criar e experimentar suas coisas.</p>

<h3>O velho que é novo</h3>

<p>Containers já existem há algum tempo dentro da nossa área com o que chamavamos de Linux Containers ou LXC. O que aparece com o Docker agora é uma maneira mais fácil de trabalhar com tudo isso e um engajamento da comunidade e das empresas de software gigantesco, trazendo uma gama de várias ferramentas prontas em formato de imagens. Com isso não vamos perder muito tempo com configurações e testar e descobrir tecnologias fica mais fácil.</p>

<p>Marque na agenda para pesquisar sobre libvirt, LXC e a história por trás da criação do Docker na França. Vale a pena!</p>

<h3>Instalação e não só para Linux</h3>

<p>Diferente dos antigos, o docker trouxe maneiras de trabalharmos com containers em qualquer sistema operacional. A maneira como ele faz isso está sempre evoluindo a cada versão. Pesquise como está para o seu sistema operacional.</p>

<p>Eu não vou tratar aqui como instalar o Docker nem sua arquitetura básica, quero ir direto aos pontos mesmo que ainda ficando muito parecido com os primeiros passos da documentação oficial. A ideia é explicar as coisas um pouquinho diferente para quem não pegou da maneira que ficou lá e trazer umas maneiras diferentes de pensar.</p>

<h3>Hello World</h3>

<p>Cada um tem a sua maneira de aprender as coisas, sujiro muito que você descubra a sua. Eu gosto de Hello World, começar do ultra básico e ir evoluindo e tentando entender passo a passo. Vamos fazer juntos e já vou explicando algumas coisas.</p>

<p>O Hello World com docker fica da seguinte maneira. Rode:</p>

<pre><code>docker run hello-world
</code></pre>

<h4>Imagens</h4>

<p>O docker vai buscar uma imagem chamada hello-world. Imagens são a base dos containers, são como um cenário pronto que pode conter um sistema operacional e um conjunto de softwares por exemplo.</p>

<p>Você não tem a imagem localmente, então o docker vai fazer o download dela. Para algumas imagens você vai ver o docker fazendo vários downloads paralelos para deixar as coisas mais rápidas.</p>

<h4>Saída</h4>

<p>Uma vez que foi feito o download da imagem o docker vai subir o container e rodar o programa hello-world sozinho.</p>

<pre><code>Hello from Docker!
This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash
</code></pre>

<p>Se é isso que aparece para você, está feito! Tudo funcionando! O docker já te provoca a tentar algo mais ambicioso e é para esse caminho que vamos:</p>

<h3>CentOS</h3>

<p>A saída do Hello World te desafia a fazer um container Ubuntu. Como muita gente usa Ubuntu como máquina principal, pessoalmente sugiro tentar outra distro no container. Que tal CentOS?</p>

<pre><code>docker run -it centos bash
</code></pre>

<p>Novamente aqui o docker vai buscar por uma imagem, dessa vez do CentOS, se não tiver vai fazer download dela.</p>

<p>Novidades no comando:</p>

<ul>
<li>-i é o comando para interagir, vai manter o STDIN aberto.</li>
<li>-t é para alocar um TTY(Talk to you) que é um terminal.</li>
</ul>


<p>Com a imagem em mãos, o docker vai subir o container e executar o comando bash.</p>

<p>Note que a linha do seu terminal mudou e você deve estar dentro do container. Todo comando que você executar agora está sendo executado dentro do seu container com Ubuntu.</p>

<p>Experimente alguns comandos para comprovar. Por exemplo: <strong>yum</strong>.</p>

<h3>Attached</h3>

<p>Vamos sair do nosso container sem matar ele. Segure CTRL e pressione P e em sequida Q.
Você está de volta para sua máquina principal. Vamos ver os containers que temos rodando?</p>

<pre><code>docker ps
</code></pre>

<p>O comando ps vai nos mostrar os containers que estão rodando com um id, o processo que estão executando, quando foram criados, seu status, portas e nome do container.</p>

<p>Como não passamos nenhum nome para nosso container, o docker deu um de seus nomes padrão.</p>

<p>Vamos voltar para nosso container CentOS? Para isso vamos fazer o seguinte comando:</p>

<pre><code>docker attach [id ou nome do container]
</code></pre>

<p>Com o ID ou nome do container, você consegue voltar para ele, o que chamam de attach.</p>

<p>Pense no Attach como você dentro do container. O padrão quando se cria um container é attach, e foi isso que aconteceu quando passamos o comando run, entramos no container.</p>

<h3>Detach</h3>

<p>De dentro do container, digite exit. Isso vai matar o container e ele não vai existir mais. O mesmo vai acontecer se você fizer um CTRL+C por exemplo.</p>

<pre><code>docker ps -a
</code></pre>

<p>Com o comando acima, além de ver seus containers ativos (se houver) ele mostra também os containers inativos. Se você deu exit em seu container do CentOS, essa mensagem vai ser mostrada em status.</p>

<p>Agora vamos criar o container novamente, mas dessa vez passando uma opção detached, ou seja, vamos criar o container mas não vamos entrar nele. Vamos também dar um nome para nosso container</p>

<pre><code>docker run --name meu-centos -itd centos bash
</code></pre>

<p>Ao rodar docker ps você vê que seu container está rodando, com o comando <strong>bash</strong> e com o nome <strong>meu-centos</strong></p>

<p><strong>Nesse ponto faça o exercício de entrar e sair de containers, criar outros e etc. Use Attach e CTRL+P+Q</strong></p>

<h3>Exec</h3>

<p>As vezes precisamos apenas executar apenas um comando dentro de um container e entrar e sair dele seria muito chato e demorado. Para isso temos o Exec:</p>

<pre><code>docker exec meu-centos echo teste
</code></pre>

<p>Aqui o docker entrou no container, executou o comando <strong>echo teste</strong> em meu-centos e retornou a sua máquina.</p>

<h3>Comandos que você talvez precise</h3>

<pre><code>#Para listar as imagens que você tem: docker images
#Para remover containers: docker rm
#Para remover imagens: docker rmi
#Parar e reiniciar container: docker start / docker stop 
</code></pre>

<h3>Fechando</h3>

<p>Aqui fizemos os pequenos primeiros passos com containers. Muito parecido com o proposto pela documentação oficial.</p>

<p>Te convido a explorar o <a href="https://hub.docker.com/">DockerHUB</a> repositório oficial de imagens para criarmos containers. Procure ferramentas que você já trabalha, ferramentas que você quer experimentar, o uso de containers vai te ajudar a fazer testes rápidos e estudar qualquer coisa.</p>

<p>Com isso acredito que sua cabeça já começe a fervilhar de ideias de para onde podemos ir.
Me comprometo a evoluir esses exemplos aqui nas próximas semanas.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant, PuPHPet E PHP Built In]]></title>
    <link href="http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in/"/>
    <updated>2013-09-15T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in</id>
    <content type="html"><![CDATA[<p>Fala pessoal.<br/>
Hoje trago uma dica simples, talvez sem uma utilidade de pronto, mas que pode ser interessante para algum estudo.</p>




<p><strong>O que é Vagrant?</strong><br/>
Para quem ainda não conhece, Vagrant é uma ferramenta que vem revolucionando os ambientes de desenvolvimento.<br/>
Se você ainda não sabe nada sobre essa ferramenta, confira o post que escrevi aqui no blog: <a href="http://flaviosilveira.com/2012/vagrant-facil-e-util/">http://flaviosilveira.com/2012/vagrant-facil-e-util/</a>.</p>




<!--more-->




<p>Alguns pontos do Vagrant:<br/>
&#8211; Com o Vagrant você não precisa instalar apache e outras ferramentas e poluir sua máquina.<br/>
&#8211; Você pode criar uma máquina virtual para cada projeto e com isso ter uma versão igual ao seu servidor de produção, com a mesma versão de PHP, de MySQL e etc.<br/>
Com isso acaba aquela desculpa de &#8220;Na minha máquina funciona!&#8221;.<br/>
&#8211; Com o Vagrant você pode distribuir o mesmo ambiente para todo seu time de desenvolvimento, evitando funcionamentos diferentes entre pessoas do mesmo time.<br/>
&#8211; Muito mais.</p>




<p><strong>PuPHPet: Arquivos puppet</strong><br/>
Com arquivos puppet (.pp) você pode definir pacotes, programas e extensões a serem instaladas na sua máquina virtual.<br/>
Geralmente são coisas complicadas e sempre acaba surgindo um problema quando são feitos esses arquivos na mão.</p>




<p>Felizmente surge o PuPHPet <a href="https://puphpet.com/">https://puphpet.com/</a>, uma ferramenta online que cria o puppet para você. Você seleciona tudo o que você quer, incluindo pacotes PEAR, pacotes PECL, etc.<br/>
Permite também setar o XDebug, timezone, escolher versão do PHP, do MySQL, incluir o composer, muito mais.</p>




<p>Dê uma atenção especial na opção BOX IP Address. Nesse campo você define o ip da sua máquina virtual.<br/>
É esse IP que você vai digitar no browser da sua máquina e acessar o seu projeto.<br/>
Por padrão o PuPHPet traz o IP 192.168.56.101.</p>




<p><strong>O que é PHP Built In?</strong><br/>
Com a versão 5.4, o PHP trouxe uma novidade para os ambientes de desenvolvimento. O PHP Buitl In.<br/>
É um web server rodando direto em cima do PHP, mas apenas com propósitos de desenvolvimento.<br/>
Com um simples comando você define a porta da onde quer rodar o servidor, e pronto. Sem precisar de Apache, NGinx ou o que for.<br/>
Uma coisa rápida para testar seu projeto. Veja detalhes na documentação: <a href="http://www.php.net/manual/pt_BR/features.commandline.webserver.php">http://www.php.net/manual/pt_BR/features.commandline.webserver.php</a></p>




<p><strong>Mãos a Obra</strong><br/>
Instale a versão mais recente do Vagrant acessando a página de downloads em <a href="http://downloads.vagrantup.com/">http://downloads.vagrantup.com/</a>.<br/>
Uma dica é ter instalado o Virtual Box para que tudo corra bem. A instalação não tem segredos.</p>




<p>Um segundo passo é configurar a sua máquina com a ajuda do PuPHPet <a href="https://puphpet.com/">https://puphpet.com/</a>.<br/>
Escolha no mínimo uma versão 5.4 do PHP. Faça o download do arquivo e posicione onde melhor julgar na sua máquina.</p>




<p>Via console, acesse essa pasta e vamos subir a sua máquina virtual com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant up
</pre>




<p>Esse comando irá fazer o download de tudo que você selecionou de configuração via PuPHPet e deixar a máquina online para você.<br/>
Ao final da configuração, você já é capaz de acessar a sua máquina via porta 80 por exemplo, digite em seu navegador o ip que foi setado no campo BOX IP Address no PuPHPet.</p>




<p>Mas que tal testar essa funcionalidade que veio com o PHP 5.4? Vamos colocar o PHP Built In para rodar.<br/>
Vamos acessar sua máquina virtual via ssh, com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant ssh
</pre>




<p>Caso você precise do root para qualquer coisa, basta colocar um sudo na frente do que precisar.</p>




<p>Vamos configurar um pequeno projeto PHP apenas para ocasião de teste. Por exemplo:</p>




<pre class="brush: bash; title: ; notranslate" title="">cd /var/www
mkdir teste
cd teste
</pre>




<p>Dentro dessa pasta teste que criamos, crie um arquivo PHP simples, com um echo por exemplo.</p>




<p>Você será capaz de acessar isso digitando seu BOX IP/teste, mas, para testar o PHP Built In, entre com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">sudo php -S 192.168.56.101:8080
</pre>




<p>Não esqueça de substituir 192.168.56.101 pelo seu BOX IP.<br/>
8080 é a porta que escolhemos aqui. Você pode definir a porta que quiser, com exceção das que já estão em uso.<br/>
** Qualquer comando executado nessa mesma janela, ou um ctrl+c irá derrubar o server.</p>




<p>Pronto, o PHP Built In está escutando na porta definida.<br/>
Você pode conferir isso abrindo um outro terminal e consultando os listenings com o comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">netstat -ln
</pre>




<p>Lembrando que esse comando pode variar de acordo com a distribuição que você selecionou na sua BOX.</p>




<p>Pronto. Você pode acessar do seu browser o seu BOX IP:PORTA e acessar o seu projeto diretamente, sem barras nem nada.<br/>
Aqui eu acessei <a href="http://192.168.56.101:8080/.">http://192.168.56.101:8080/.</a></p>




<p><strong>Resumindo</strong><br/>
Escrevi esse post apenas como curiosidade. Sei que ele pode não ter nenhuma aplicação prática, mas de repente é uma para o pessoal conhecer o PHP Built In e ver até onde ele vai e porque ele está apenas disponível para desenvolvimento.</p>




<p>Grande Abraço!</p>

]]></content>
  </entry>
  
</feed>
