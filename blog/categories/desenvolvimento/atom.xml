<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Desenvolvimento | Flávio Silveira]]></title>
  <link href="http://flaviosilveira.com/blog/categories/desenvolvimento/atom.xml" rel="self"/>
  <link href="http://flaviosilveira.com/"/>
  <updated>2017-02-13T01:04:47+00:00</updated>
  <id>http://flaviosilveira.com/</id>
  <author>
    <name><![CDATA[Flávio Silveira]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Criando Seu Container Com Dockerfile]]></title>
    <link href="http://flaviosilveira.com/2017/criando-seu-container-com-dockerfile/"/>
    <updated>2017-02-12T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2017/criando-seu-container-com-dockerfile</id>
    <content type="html"><![CDATA[<p>Foi uma longa jornada até criarmos nosso container da maneira que queríamos <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-1/">flaviosilveira.com/2017/criando-seu-container-nginx-php-1/</a> e <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2/">flaviosilveira.com/2017/criando-seu-container-nginx-php-2/</a>. Ainda assim temos alguns pontos chatos como o de ter de iniciar o Nginx e o PHP-FPM Manualmente.</p>

<p>Felizmente há uma maneira mais simples de montarmos nosso container e ainda fugindo do trabalho manual. Vamos usar Dockerfile!</p>

<p>Dockerfile é um arquivo onde colocamos tudo o que precisamos para nosso container. De qual container ele se origina, o que você quer instalar, que serviços quer rodar.</p>

<p>Se você está acompanhando a série de artigos sobre docker, basicamente vamos traduzir o que fizemos nos dois artigos anteriores para um Dockerfile.</p>

<p>No decorrer deste artigo vou me referir aos 2 anteriores praticamente o tempo todo. Caso você não os tenha lido, pode ficar um pouco fora de contexto para você, mas nada que vá comprometer o entendimento final.</p>

<!--more-->


<h3>Preparação</h3>

<p>Crie uma pasta chamada <em>docker-test</em>, e dentro dela crie um arquivo chamado <em>Dockerfile</em>. Com a inicial maiúscula e sem extensão.</p>

<p>Isso é tudo que vamos precisar.</p>

<h3>Container de origem</h3>

<p>No começo da parte 1 do artigo falamos sobre de qual container partiríamos. Entre Ubuntu e Debian, ficamos com o Debian.</p>

<p>Para dizer isso para o Dockerfile, usamos <strong>FROM</strong></p>

<pre><code>FROM debian
</code></pre>

<p>Com essa diretiva, estamos partindo da última imagem do debian presente no DockerHub.</p>

<h3>Assine sua imagem</h3>

<p>Use <em>MAINTENER</em> para assinar sua imagem, dizer aos outros quem é o mantenedor dela.
No meu caso:</p>

<pre><code>MAINTAINER Flavio Silveira
</code></pre>

<h3>Atualização e instalações</h3>

<p>Passamos algum tempo atualizando o sistema e em seguida instalando o NGinx e o PHP-FPM. Fizemos isso de fora do container usando o comando <em>docker exec</em>.</p>

<p>No Dockerfile usamos RUN para criar o ambiente da nossa imagem</p>

<pre><code>RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get install -y php5-fpm
</code></pre>

<p>Essas 3 linhas resumem muito do trabalho que foi feito na parte 1 do artigo. Elas indicam respectivamente que queremos atualizar o sistema operacional e em seguida instalar o NGinx e o php5-fpm. Simples assim!</p>

<h3>Configurações</h3>

<p>Para configurar nosso container, entramos nele com o comando <em>docker attach</em> e criamos e alteramos o arquivo <em>/etc/nginx/sites-available/default</em>. Fizemos um arquivo bem enxuto funcionando na porta <em>80</em> e apontando para <em>/var/www/app</em>.</p>

<p>Copie o trabalho que fizemos com o arquivo default dentro do container para um arquivo local, dentro de nossa pasta <em>docker-test</em>, chame ele de <em>default</em>.</p>

<p>Agora vamos dizer para o Dockerfile que queremos copiar esse arquivo para a configuração do Nginx.</p>

<pre><code>COPY default /etc/nginx/sites-available/default
</code></pre>

<p>O primeiro parâmetro é o arquivo em nossa máquina, e o segundo é o lugar que ele vai parar em nossa imagem.</p>

<p>Os passos de criar a pasta app, não serão necessários. Você vai ver como o container vai se virar com isso sem trazer a dor de cabeça para você.</p>

<h3>Fechando sua imagem</h3>

<p>Na parte 2 do artigo anterior criamos a imagem a partir do container que estavamos rodando. Infelizmente tinhamos de iniciar o NGinx e o PHP-FPM manualmente após fazer download da imagem para fazer as coisas acontecerem.</p>

<p>Aqui no Dockerfile vamos resolver esse problema.</p>

<p>Uma vez que nosso ambiente foi preparado com os comandos anteriores, agora vamos usar <em>CMD</em> para dizer como nosso container vai rodar.</p>

<pre><code>CMD service nginx start &amp;&amp; service php5-fpm start &amp;&amp; /bin/bash
</code></pre>

<p>Repare que diferente da diretiva <em>RUN</em>, com <em>CMD</em> concatenamos os comandos usando <em>&amp;&amp;</em>. Precisamos disso pois só podemos ter um <em>CMD</em> no Dockerfile.</p>

<p>Aqui respectivamente iniciarmos o Nginx, em seguida o PHP-FPM e executamos <em>/bin/bash</em> para que o container fique de pé quando iniciado.</p>

<p>Caso a gente não use esse <em>/bin/bash</em> aqui, teremos que passar ele quando rodarmos a imagem com <em>docker run</em>.</p>

<h3>Nosso Dockerfile</h3>

<p>É isso! Já temos tudo o que precisamos no nosso <em>Dockerfile</em>.
Vejam como ficou:</p>

<pre><code>FROM debian

MAINTAINER Flavio Silveira

RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get install -y php5-fpm

COPY default /etc/nginx/sites-available/default

CMD service nginx start &amp;&amp; service php5-fpm start &amp;&amp; /bin/bash
</code></pre>

<h3>Construindo a imagem</h3>

<p>Para construir a imagem a partir do Dockerfile vamos executar o comando docker build.</p>

<pre><code>docker build -t flaviosilveira/php-nginx-2 .
</code></pre>

<p>Usamos o parâmetro -t para dar a nossa imagem um apelido, uma tag para que fique mais fácil levantar ela depois. Assim como no artigo anterior, coloque seu nome de usuário do DockerHub na frente da tag da imagem. Isso será necessário na hora do envio da imagem. No meu caso ficou <em>flaviosilveira/php-nginx-2</em>.</p>

<p>O ponto no final, indica o diretório aonde está o Dockerfile que você criou.</p>

<p>Você verá o docker executar passo a passo do seu Dockerfile em detalhes, acompanhe no seu terminal.</p>

<h3>Checando sua imagem e dando run</h3>

<p>Com o comando <em>docker images</em> você vê sua imagem criada localmente. Vamos testa-lá?</p>

<pre><code>docker run --name usando-dockerfile -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx-2
</code></pre>

<p>Coloquei um nome para meu container de <em>usando-dockerfile</em>.</p>

<p>Passamos a referência de portas, a 8080 de nossa máquina vai bater na 80 do container.</p>

<p>Compartilhei uma pasta local minha <em>~/dev/php</em> para a pasta <em>/var/www/app</em> do container. Tudo que que for feito na pasta local, vai refletir na pasta dentro do container. <em>/var/www/app</em> é o local para onde nosso config do NGinx aponta como diretório raiz.</p>

<p>Faça os testes com seus arquivos PHP e veja em funcionamento.</p>

<p>Caso queira, acesse o container e confirme que seus serviços estão rodando e que o arquivo de configuração do NGinx foi copiado.</p>

<h3>Enviando ao Dockerhub</h3>

<p>Para enviar a imagem para o DockerHub, vamos fazer o mesmo processo do artigo anterior.</p>

<pre><code>docker login
</code></pre>

<p>Caso não tenha usuário no DockerHub, não esqueça de criar antes.</p>

<p>E para enviar a imagem</p>

<pre><code>docker push flaviosilveira/php-nginx-2
</code></pre>

<p>Use com a tag que deu para sua imagem, com seu nome de usuário.</p>

<p>É isso! Acesse o DockerHub para conferir.</p>

<h3>Testando</h3>

<p>Seguindo o mesmo que fizemos no final do último artigo vamos testar.</p>

<p>Antes de testar, vamos eliminar tudo que temos localmente, parar o container e remover a imagem.</p>

<pre><code>docker stop usando-dockerfile
docker rm usando-dockerfile
docker rmi flaviosilveira/php-nginx-2
</code></pre>

<p>Agora executamos o mesmo run que fizemos acima.</p>

<pre><code>docker run --name usando-dockerfile -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx-2
</code></pre>

<p>A imagem não será encontrada localmente e será feito download dela diretamente do DockerHub.</p>

<p>Veja seu container rodando:</p>

<pre><code>docker ps
</code></pre>

<p>Viram como foi muito mais fácil usar o Dockerfile para criar nosso container? Por hoje é isso!</p>

<p>Grande abraço e até a próxima.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Criando Seu Container NGinx + PHP (Parte 2)]]></title>
    <link href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2/"/>
    <updated>2017-01-14T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2</id>
    <content type="html"><![CDATA[<p>No final da <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-1">parte 1 desse artigo</a>, onde montamos um container com Debian, NGinx e PHP, nos deparamos com o seguinte: Se pararmos nosso container e precisar novamente de NGinx + PHP, teremos que partir do zero.</p>

<p>Para evitar isso, vamos criar nossa própria imagem, uma imagem que vai guardar o que fizemos até agora.</p>

<!--more-->


<h3>Saia do container</h3>

<p>Primeiro vamos sair de nosso container com <strong><em>ctrl+p</em></strong> e em seguida <strong><em>ctrl+q</em></strong>.<br/><strong><em>Dica:</em></strong> Não precisa soltar o ctrl.</p>

<h3>Conta no DockerHub</h3>

<p>Vá até o DockerHub <a href="https://hub.docker.com/">https://hub.docker.com</a> e crie sua conta.</p>

<p>Após isso volte para o terminal e faço o comando de login</p>

<pre><code>docker login
</code></pre>

<p>Irá pedir seu usuário e senha e feito!</p>

<h3>Criando Imagem</h3>

<p>Para criar sua imagem, você vai precisar do <strong><em>ID</em></strong> do seu container, use <strong><em>docker ps</em></strong> para consultar. A primeira coluna vai te mostrar seu <strong><em>CONTAINER ID</em></strong>.</p>

<p>Em seguida, execute o commit com o comando abaixo:</p>

<pre><code>docker commit id-do-seu-container flaviosilveira/php-nginx
</code></pre>

<p>Substitua no comando acima <strong><em>id-do-seu-container</em></strong> pelo id mostrado em <strong><em>docker ps</em></strong>.</p>

<p>Fora o id, colocamos o nome que desejamos para nossa imagem. Escolhi php-nginx.</p>

<p>Repare que coloquei meu nome de usuário do DockerHub na frente do nome que quero para a imagem. Isso será necessário na hora do envio para o DockerHub.</p>

<p>O comando vai te retornar um hash SHA-256.</p>

<p>Confira sua imagem criada</p>

<pre><code>docker images
</code></pre>

<p>Sua imagem deve estar no topo dessa lista.</p>

<h3>Usando sua imagem localmente</h3>

<p>Uma vez que vemos a imagem no comando <strong><em>docker images</em></strong>, você já pode usar ela localmente.
<strong><em>ATENÇÃO:</em></strong> Altere o meu nome de usuário abaixo pelo seu.</p>

<pre><code>docker run --name usando-imagem -itd -p 8080:80 flaviosilveira/php-nginx
</code></pre>

<p>Pontos de atenção:</p>

<ul>
<li>Como nossa imagem é baseada na do Debian, rodamos ela de maneira igual. Compare o comando run executado aqui com o da parte 1 desse artigo.</li>
<li>Coloquei a porta 8080 do nosso host para apontar para a 80 do container (-p 8080:80), para não conflitar com a porta 80 do outro container (-p 80:80).</li>
</ul>


<p>Outra coisa. O serviço do NGinx e do PHP5-FPM estão parados!</p>

<p>Você precisa iniciar eles para ver as coisas funcionando.</p>

<pre><code>docker exec minha-imagem service nginx start
docker exec minha-imagem service php5-fpm start
</code></pre>

<p>Agora confira o resultado em <strong><em>localhost:8080</em></strong>.</p>

<h3>Enviando sua imagem para o DockerHub</h3>

<p>Já vimos em outros artigos o comando <strong><em>docker pull</em></strong> que serve para fazermos download de imagens para nossa máquina. Por padrão ele busca imagens do DockerHub, repositório padrão do docker.</p>

<p>Agora para enviarmos imagens para ele, temos o <strong><em>push</em></strong></p>

<pre><code>docker push flaviosilveira/php-nginx
</code></pre>

<h3>Testando</h3>

<p>Antes de testar, vamos eliminar tudo que temos localmente. Parar o container e remover a imagem.</p>

<pre><code>docker stop usando-imagem
docker rm usando-imagem
docker rmi flaviosilveira/php-nginx
</code></pre>

<p>Agora basta tentar executar o mesmo run que fizemos acima.</p>

<pre><code>docker run --name usando-dockerhub -itd -p 8080:80 flaviosilveira/php-nginx
</code></pre>

<p>A imagem não será encontrada localmente e será feito download dela diretamente do docker hub.</p>

<p>Veja seu container rodando</p>

<pre><code>docker ps
</code></pre>

<p>Ou dê start no NGinx e no PHP-FPM e acesse no seu navegador na porta 8080 como colocamos acima.</p>

<h3>Compartilhando seus arquivos php com o container</h3>

<p>Para compartilhar seus arquivos locais de PHP com o container, use o parâmetro de volume, como fizemos no artigo de <a href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/">docker com PHP Built in</a>.</p>

<pre><code>docker run --name usando-dockerhub -itd -p 8080:80 -v ~/dev/php:/var/www/app flaviosilveira/php-nginx
</code></pre>

<p>No parâmetro -v, você coloca o caminho da sua pasta local e separado por : (dois pontos) temos a pasta root que definimos no nosso NGinx.</p>

<p>Acesse o navegador para constatar.</p>

<h3>Resumo e Próximos passos?</h3>

<p>Nesse artigo dividido em duas partes fizemos bastante coisa:
<br/>Usamos uma imagem debian, instalamos NGinx e PHP de fora do container com <strong><em>exec</em></strong> e depois entramos nele para configurar as coisas.</p>

<p>Criamos um login no dockerHub, criamos uma imagem nossa e agora ela está disponível para quem precisar.</p>

<p>Mas a maneira como fizemos não deixa claro de que imagem partimos ou ainda caso a gente desista de usar Debian e queira usar CentOS, você vai ter que novamente partir do zero dessa maneira que fizemos.</p>

<p>Nossos próximos passos são aprender um pouco sobre tags e criar nossa imagem usando DockerFile, que também vai nos ajudar a parar com a chatisse de ter que iniciar o php e o NGinx manualmente.</p>

<p>Vamos para um post sobre isso?</p>

<p>Até lá! Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Criando Seu Container NGinx + PHP (Parte 1)]]></title>
    <link href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-1/"/>
    <updated>2017-01-14T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2017/criando-seu-container-nginx-php-1</id>
    <content type="html"><![CDATA[<p>Fala pessoal!<br/>Esse já é nosso terceiro artigo sobre docker:</p>

<ul>
<li>Já vimos como podemos iniciar com o Docker no artigo <a href="http://flaviosilveira.com/2016/comece-com-docker/">http://flaviosilveira.com/2016/comece-com-docker</a>.</li>
<li>Em seguida vimos como iniciar um Container com PHP 7 e usar seu servidor embutido (built in) em <a href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/">http://flaviosilveira.com/2016/docker-php7-e-php-built-in</a>.</li>
</ul>


<p>Com isso já conseguimos trabalhar com o PHP, mas o servidor Built-in não é a maneira ideal para isso. Como podemos colocar o PHP como um todo rodando em um container Docker para a gente? Vamos responder a isso.</p>

<p>Para quem não leu os primeiros dois artigos citados acima, recomendo. Acredito que vá ficar melhor de entender o que vem abaixo. Temos bastante <em>tecnês</em>.</p>

<!--more-->


<h3>Sim, tem pronto por aí!</h3>

<p>Nos artigos anteriores falamos sobre o DockerHub, repositório oficial de imagens para criarmos nossos containers. Estamos buscando um container que tenha para a gente um PHP e um NGinx, e claro que tem várias imagens prontas disso por aí.</p>

<p>Inclusive a que criamos nesse tutorial <a href="https://hub.docker.com/r/flaviosilveira/php-nginx/">https://hub.docker.com/r/flaviosilveira/php-nginx</a>.</p>

<p>Mas, para aprendermos algo novo, vamos construir nosso próprio container e com ele criar nossa imagem. Se você entendeu o conceito de containers e o que ele pode te trazer, pare e pense as maneiras que você teria para fazer isso.</p>

<p>Conseguiu pensar em algumas?</p>

<h3>Nossa maneira</h3>

<p>Que tal partirmos de um sistema operacional? Vamos de Debian. Acredito que é o meio caminho entre o que muitos conhecem, que é o Ubuntu, e legal para sair um pouco do mesmo.</p>

<p>Todos os comandos abaixo já foram explicados nos artigos anteriores. Volta lá se perdeu algo!</p>

<p>Lembrem-se do que sempre digo: <strong><em>Não é complicado! Se ficar complicado demais tem algo errado, volte e leia novamente, com mais calma</em></strong>.</p>

<h4>SO</h4>

<p>Rodando um container Debian, vmaos chamar ele de <strong><em>server</em></strong>:</p>

<pre><code>docker run --name server -itd -p 80:80 debian
</code></pre>

<p>Confira seu container rodando</p>

<pre><code>docker ps
</code></pre>

<p>Vamos dar um update no Debian para dessa maneira ele atualizar os caminhos dos pacotes:</p>

<pre><code>docker exec server apt-get update
</code></pre>

<h4>NGinx</h4>

<p>Terminado, podemos partir para a instalação do NGinx:<br/><strong>ATENÇÃO:</strong> não esqueça do -y abaixo, ele serve para confirmar que você quer instalar o pacote. As vezes sem essa opção a saída não vem corretamente do container para sua máquina.</p>

<pre><code>docker exec server apt-get install nginx -y
</code></pre>

<p>Vamos checar se instalou tudo certo?</p>

<pre><code>docker exec server nginx -v
</code></pre>

<p>A saída deve ser algo como:</p>

<pre><code>nginx version: nginx/1.6.2
</code></pre>

<p>O NGinx está instalado, mas ainda não está rodando. Vamos iniciar ele?</p>

<pre><code>docker exec server service nginx start
</code></pre>

<p>Agora que o NGinx está rodando, você já é capaz de ir ao seu localhost e ver a página inicial do NGinx.</p>

<h4>PHP</h4>

<p>Vamos agora instalar o PHP. Antes disso, vamos checar quais versões do PHP temos disponível para o Debian nessa versão.</p>

<pre><code>docker exec server apt-cache search php | grep fpm
</code></pre>

<p>Aqui retornou a versão 5 do FPM. Vamos com ela.<br/><strong>ATENÇÃO:</strong> não esqueça do -y.</p>

<pre><code>docker exec server apt-get install php5-fpm -y
</code></pre>

<p>Vamos checar se instalou tudo certo?</p>

<pre><code>docker exec server php --version
</code></pre>

<p>A saída deve ser algo como:</p>

<pre><code>PHP 5.6.29-0+deb8u1 (cli) (built: Dec 13 2016 16:02:08) 
Copyright (c) 1997-2016 The PHP Group
Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies
    with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2016, by Zend Technologies
</code></pre>

<p>Para fechar igual a instalação do NGinx que fizemos acima, vamos iniciar o php-fpm?</p>

<pre><code>docker exec server service php5-fpm start
</code></pre>

<p>Feito!</p>

<p>Sim! Você pode adicioanar os caminhos no debian para instalar a versão 7 do PHP. Aqui fizemos com a versão que havia disponível para facilitar esse tutorial.</p>

<h3>Hora de Configurar</h3>

<p>Sistema Operacional, NGinx e PHP ok. Hora de configurar as coisas para rodarem.
Acima executamos todos os comandos de fora do container com <strong><em>docker exec</em></strong>. Agora como vamos editar arquivos de configuração, acho que é melhor irmos para dentro do container.</p>

<pre><code>docker attach server
</code></pre>

<p>Seu terminal deve ter ficado com algo como <strong><em>root@id-do-seu-container</em></strong>. Estamos dentro do container!</p>

<p>Para editar arquivos vamos precisar de um editor. Vou de <strong><em>Vim</em></strong>, e vocês? Instalem o editor que você tiverem facilidade.</p>

<p><strong><em>ATENÇÃO:</em></strong> Lembra do -y nos comandos acima? Aqui não passamos esse parâmetro. Então você terá que responder com <strong><em>Y</em></strong> se você deseja instalar o pacote quando for questionado por isso. Ou adicione o <strong><em>-Y</em></strong> no comando abaixo ;-)</p>

<pre><code>apt-get install vim
</code></pre>

<p>Com o editor em mãos, vamos configurar o NGinx.
Vamos ao arquivo default de configuração. Nessa versão ele está no seguinte caminho:</p>

<pre><code>vim /etc/nginx/sites-available/default
</code></pre>

<p>O Arquivo vem com várias linhas comentadas para facilitar o seu entendimento.
Segue o meu arquivo abaixo. Deixei o mais enxuto para ele funcionar na porta 80.</p>

<pre><code>server {
    listen   80;

    root /var/www/app;
    index index.php index.html;

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
</code></pre>

<p>Após editar o arquivo, reinicie o <strong><em>NGinx</em></strong></p>

<pre><code>service nginx restart
</code></pre>

<p>Repare que colocamos como raiz o caminho <strong><em>/var/www/app</em></strong>.
Vamos até <strong><em>/var/www</em></strong></p>

<pre><code>cd /var/www
</code></pre>

<p>Agora criamos a pasta app</p>

<pre><code>mkdir app
</code></pre>

<p>Vamos criar um arquivo <strong><em>index.php</em></strong> com uma função <strong><em>phpinfo</em></strong> dentro dele para fazermos um teste.</p>

<pre><code>&lt;?php phpinfo(); ?&gt;
</code></pre>

<p>Acesse localhost e veja o resultado.</p>

<h3>Hmm.. mas quando eu derrubar esse container?</h3>

<p>É, você vai ter que fazer tudo novamente. Mas não entre em pânico! Que tal criarmos nossa própria imagem, e sempre que quisermos um container com NGinx+PHP, podemos usar nossa própria imagem. Como te parece?</p>

<p>Vamos para a parte 2 desse artigo para pegar essa ideia <a href="http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2">http://flaviosilveira.com/2017/criando-seu-container-nginx-php-2</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microserviços]]></title>
    <link href="http://flaviosilveira.com/2016/microservicos/"/>
    <updated>2016-11-07T08:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/microservicos</id>
    <content type="html"><![CDATA[<p>Muito anda se falando sobre microserviços e trago para vocês minha experiência de como começamos a trabalhar dessa forma aqui na <a href="https://www.lojaskd.com.br">LojasKD</a>.</p>

<p>Assim como meu post anterior sobre <a href="http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce/">Ansible e automação</a>, esse assunto também faz parte de uma palestra que apresentei durante 2016, um dos meus grandes orgulhos desse ano que encerro com esse post.</p>

<h3>Microserviços - O que é?</h3>

<p>Para falar sobre microserviços eu sempre empresto a frase do <a href="https://twitter.com/tiagodolphine">@tiagodolphine</a>: &ldquo;O menor possível, porém grande o suficiente para representar seu domínio&rdquo;.</p>

<!--more-->


<p>Pequenas aplicações que representem seus domínios. Parece fácil ah?
Mas a linha para que isso se torne um <strong>macroserviço</strong> é tênue. Se você descuidar da organização dos seus serviços eles podem começar a dar mais trabalho do que você gostaria.</p>

<h3>Seus problemas não acabaram</h3>

<p>Não existe solução perfeita, tudo tem seu uso ideal, seu lado bom e seu lado ruim.</p>

<p>Microserviços não são uma bala de prata que vai resolver todos os problemas de seus projetos. Assim como você escolhe uma linguagem para desenvolver um projeto, qual banco de dados vai usar e etc, o mesmo deve servir para sua arquitetura.</p>

<p><strong>Não vá de microserviços simplesmente pelo modismo!</strong></p>

<p>Aliás, microserviços pode ser comparado ao que acontecia com APIs em SOAP (Simple Object Access Protocol) com seus WSDLs para lá e para cá, que tem seus primeiros registros de uso no fim dos anos 90. Tecnologia tem muito disso, coisas que voltam com nomes diferentes ou um buzz que surge com coisas que já fazemos.</p>

<p>Acompanhem comigo os prós e contras de uma arquitetura monolítica versus uma de microserviços.</p>

<h3>Monolítico</h3>

<p>Há não tantos anos atrás, na hora de iniciar nossos projetos era certo que eles seriam de uma forma única. Como estamos falando da KD aqui, vamos pegar o exemplo de ECommerce.</p>

<p>Um banco de dados, uma aplicação MVC em cima de uma linguagem. Um controller para a Vitrine, outro para o Carrinho, outro para o Checkout. Tudo em um lugar só.</p>

<p>Mas então quando seu serviço cai? Tudo cai, tudo fica fora. <strong>-1 aqui para o monolítico</strong>. Mas, na hora de colocar isso em produção? Demais! Tudo em um só lugar, um único deploy. <strong>+1 para o monolítico</strong>.</p>

<p>Se uma das partes do seu sistema ficava lento, grande chance de ele ficar lento por inteiro. E a parte que está deixando lento, que digamos seja lá na visualização de produtos, está impedindo que pessoas fechem suas compras. <strong>-1 para o monolítico</strong>.</p>

<p>Vamos monitorar para que não caia novamente? Vamos ter que monitorar uma única aplicação, Ótimo! <strong>+1 para o monolítico</strong>.</p>

<p>Achar desenvolvedores para um projeto com uma linguagem só é um outro ponto positivo aqui e também o conhecimento em cima de como servir uma única aplicação. <strong>+2 para o monolítico</strong>. Mas a curva de aprendizagem em cima de regras de negócio que estão todas juntas e misturadas podem complicar. <strong>-1 para o monolítico</strong>.</p>

<h3>Os Microserviços</h3>

<p>Em microserviços não vamos pensar como uma coisa só, vamos pensar como várias pequenas partes para formar um objetivo comum. Nosso Carrinho, nossa Vitrine, nosso Checkout que estavam todos juntos, aqui se separam em pequenas aplicações cada uma com sua função.</p>

<p>Se um dos nossos serviços caírem, outros serviços continuam funcionando e nosso ECommerce não fica totalmente fora. <strong>+1 para os microserviços</strong>.</p>

<p>Mas fazer deploy de tudo, várias aplicações. E se uma depender de outra em determinada funcionalidade? E se&hellip; É, a orquestração de entregas com microserviços pode não ser simples. <strong>-1 para os microserviços</strong>.</p>

<p>Lentidão em um dos serviços? Não deve afetar o restante. <strong>+1 para os microserviços</strong>. Ainda você pode escalar as funcionalidades de uma maneira mais flexível. Exemplo: Você tem muito mais acessos na vitrine do que no carrinho? Coloque mais máquinas para servir sua parte de vitrines, deixe a parte do carrinho com menos máquinas. É uma maneira de otimizar custos usando microserviços.</p>

<p>Agora, monitorar várias aplicações, ter uma arquitetura maior para cuidar. <strong>-1 para os microserviços</strong>.</p>

<h3>Tecnologias Agnósticas</h3>

<p>Dei a entender em um dos pontos acima que com microserviços teremos várias linguagens. Isso não é regra, claro! Mas com uma arquitetura em microserviços fica muito mais fácil você experimentar uma nova linguagem para solucionar algum problema. Se não der certo, tudo bem! O Serviço está pequeno o suficiente para você rescrever ele em uma linguagem do seu domínio em pouco tempo.</p>

<p>Coloco isso como dois pontos positivos dos microserviços: Você poder experimentar novas linguagens, poder colocar junto linguagens que não acreditam umas nas outras, descobrir novos conceitos de programação de maneira fácil sem complicar todo um negócio. E a facilidade em reescrever se for necessário. É pequeno, é rápido reescrever. <strong>+2 para os microserviços</strong>.</p>

<p>Mas, na hora de contratar pessoal para mexer com várias linguagens você pode ter um problema. <strong>-1 para os microserviços</strong>.</p>

<h3>Quem ganhou?</h3>

<p>Se você está fazendo a matemática dos pontos acima, você está perdendo. Veja o que se aplica melhor para sua necessidade e o que você pode ganhar com cada uma. Novamente, não há melhor ou pior, são soluções distintas.</p>

<p>O que você usaria para provar um conceito de uma ideia para startup? Para um hot site? Um portal de notícias? Um site institucional? Um sistema administrativo?</p>

<p>Recomendo aqui a audição do Episódio #1 do Hipsters ponto tech, <a href="http://hipsters.tech/tecnologias-no-nubank-hipsters-01/">http://hipsters.tech/tecnologias-no-nubank-hipsters-01/</a> onde o pessoal do NuBank comenta sobre a escolha de microserviços desde o início, e suposições do que poderia ter acontecido se não tivessem ido por esse caminho.</p>

<h3>Comunicação entre microserviços</h3>

<p>Várias aplicações, várias linguagens, como uma vai conversar com a outra?</p>

<p>Estamos em 2016 e para comunicar linguagens diferentes hoje temos padrões como REST, JSON que são simples de trabalhar e estão presentes em todo o lugar. Diferente dos antigos e trabalhosos XMLs com WSDLs que infelizmente ainda encontramos por aí.</p>

<h3>Bancos de dados Agnósticos</h3>

<p>Muito do que falamos acima para aplicações e linguagens, podem vir de encontro também ao pensar em banco de dados. Porque um banco de dados monolítico? Se ele ficar comprometido pode comprometer todo seu negócio.</p>

<p>Você poder experimentar bancos de dados diferentes em busca de soluções diferentes, performances de cada um e etc. Um banco de dados para produtos, outro banco de dados para pedidos e assim por diante.</p>

<p>Ah, mas como vou tirar relatórios para os meus diretores com várias bases? Como vou unir os dados de uma base com a outra? A resposta aqui pode ser BI. Business Inteligence. Una as informações que sua empresa precisa para seus KPIs e OKRs em um único ponto, onde eles possam montar seus relatórios em uma única ferramenta.</p>

<h3>Na KD</h3>

<p>Agora que já comentamos alguns pontos gerais de microserviços e estruturas monolíticas. Segue alguns pontos da nossa experiência com microserviços aqui na LojasKD:</p>

<ul>
<li><p>Os Microserviços chegaram na KD para resolver um problema de software legado. Foi a maneira que encontramos para ir substituindo as funcionalidades de uma grande aplicação monolítica aos poucos, até que não tenhamos mais ela. Estamos nesse rumo.</p></li>
<li><p>Como não tinhamos nenhuma experiência com microserviços, começamos com algo minúsculo. Um serviço que apenas trazia as informações de um pedido quando passado seu ID.</p></li>
<li><p>Começamos a experimentar linguagens e bases de dados diferentes em busca de soluções melhores para problemas conhecidos.</p></li>
<li><p>Já erramos e tivemos que reescrever microserviços inteiros novamente, mas não levou mais que uma semana.</p></li>
<li><p>Para serviços mais críticos, mantemos em nossa linguagem de maior domínio hoje, PHP.</p></li>
<li><p>Sofremos um pouco com monitoramento. É bastante coisa  para monitorar, disparar alertas e ficar de olho. Custo e trabalho em cima disso são altos.</p></li>
<li><p>A manutenção dos servers não é tão crítica, temos receitas em puppet e dockerfiles que nos ajudam nessa área.</p></li>
<li><p>Os deploys estão automatizados, mas as vezes precisamos fazer uma orquestração verbal para evitar conflitos.</p></li>
<li><p>Nosso time de desenvolvedores trabalham em cima de todos os microserviços e em suas diferentes linguagens. Temos Node, Python, Ruby, Java, GOLang e o já citado PHP. Sofremos um pouquinho na hora de contratar pessoas hoje. Não queremos desenvolvedores que saibam todas essas linguagens, mas o que acontece é que os candidatos acabam assustados com a diversidade.</p></li>
</ul>


<p>-É natural que um desenvolvedor entenda mais de uma linguagem do que de outra e vá guiando o time.</p>

<ul>
<li><p>Não descuide do tamanho dos microserviços. Mantenha uma documentação básica no mínimo.</p></li>
<li><p>Estude sobre API Gateway.</p></li>
</ul>


<p>Espero que minha abordagem para explicar microserviços tenha ajudado.
Mas e vocês, como estão usando microserviços? Ou como estão pretendendo usar?
Dúvidas? Outras ideias? Só comentar.
Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ansible - Desperte a Automação Em Você]]></title>
    <link href="http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce/"/>
    <updated>2016-10-17T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce</id>
    <content type="html"><![CDATA[<p>
Automação vem se tornando um tema essencial em empresas que querem crescer com mais cérebro e menos braço. Aquela tarefa que você repete mais de duas vezes já deve ser pensada em uma maneira de ser automática, concorda?</p>

<p>No universo do desenvolvimento, quantas são as tarefas que repetimos quando se trata de máquinas? Deploys, extração de logs, instalação e configuração de ferramentas, etc. Ansible pode ser a ferramenta que vai te ajudar a automatizar tudo isso.</p>

<!--more-->


<p>Durante esse ano de 2016 apresentei a palestra <strong><em>Automações com Ansible</em></strong> onde o objetivo principal foi uma iniciação ao Ansible. Como usar ele de maneira bem básica e se iniciar na automação. Estrutura de um projeto básico, como criar as primeiras tarefas, passar argumentos, variáveis, e usar includes. Essa vai ser a agenda desse longo post técnico e assim também encerrando as apresentações dessa palestra para dar lugar a outras :-).</p>

<h4>Ansible</h4>

<p>Ansible (<a href="https://www.ansible.com/">https://www.ansible.com/</a>) é uma ferramenta Open Source em Python para automatizar ações em máquinas. Ela é super simples, e esse é sempre um dos meus lemas quando se trata de desenvolvimento e tecnologia. Se está difícil, tem alguma coisa errada. Pare e analise. Tecnologia não é mágica, tem que fazer sentido.</p>

<p>Não vou falar da instalação do Ansible. É fácil você fazer download dele e sair rodando ou ainda usar <strong>yum install</strong> ou <strong>apt-get install</strong>.</p>

<h4>Um projeto básico</h4>

<p>Há várias maneiras de estruturar um projeto ansible. Algumas sugestão com arquiteturas de pastas super elaboradas, onde podem fazer sentido para algumas soluções. Para agora, para começarmos, dois arquivos vão resolver nosso problema.</p>

<pre><code>- projeto.yml
- hosts
</code></pre>

<p>Um arquivo com extensão .yml (yet another markup language) e um arquivo hosts, sem extensão.
No arquivo yml você vai colocar o passo a passo da sua automação. Tecnicamente ele tem o nome de playbook. No arquivo hosts vamos apontar as máquinas onde as tarefas serão executadas.</p>

<h4>Arquivo hosts</h4>

<p>Vamos primeiro configurar as máquinas que serão afetadas pelas nossas tarefas.</p>

<pre><code>#This is the Host File.

[projeto]
192.168.5.6 ansible_ssh_user=user ansible_ssh_pass=pass
</code></pre>

<p>É isso que vocês precisam no arquivo hosts quando falamos de acesso que o ansible vai fazer usando ssh. O IP da máquina, seguido de um usuário e senha. Esse nome em colchetes vai te ajudar a gerenciar as coisas em um futuro, mantenha ele ali.</p>

<p>Vai fazer uso de portas? Acesso a máquinas com chave? Chamar mais de uma máquina?</p>

<pre><code>#This is the Host File.

###################
# Projeto servers #
###################
[projeto-homologacao]
222.222.222.222:2123 ansible_ssh_private_key_file=/.ssh/chave.pem ansible_ssh_pass=pass
123.123.123.123:2123 ansible_ssh_private_key_file=/.ssh/chave.pem ansible_ssh_pass=pass

[projeto-local]
192.168.5.6 ansible_ssh_user=user ansible_ssh_pass=pass
</code></pre>

<p>Para acessar as máquinas usando chaves use <strong>ansible_ssh_private_key_file</strong>. Se seu acesso tem portas diferentes, basta adicionar elas ao final do IP.</p>

<p>Notem que fiz uma separação entre as máquinas de homologação e a máquina local. Essa organização pode te ajudar no futuro a gerenciar essas máquinas e usar isso em suas automações.</p>

<h4>Rodando o Ansible</h4>

<p>Para rodar o ansible o comando é fácil</p>

<pre><code>ansible-playbook -i hosts projeto.yml
</code></pre>

<p>Ansible-playbook é o comando. -i  é o parâmetro que significa inventory, para inventário, onde passaremos nosso arquivo hosts. Por último nosso arquivo de tarefas. Sim! Não temos nenhuma tarefa, já vamos chegar lá.</p>

<p>Caso precise rodar o ansible com mais saidas de log, em um momento para resolver problemas por exemplo, você pode usar -v, de verbose.</p>

<pre><code>ansible-playbook -i hosts projeto.yml -v
ansible-playbook -i hosts projeto.yml -vv
ansible-playbook -i hosts projeto.yml -vvv
ansible-playbook -i hosts projeto.yml -vvvv
</code></pre>

<p>As opções vão até 4 Vs. Onde cada um a mais, te mostra mais detalhes dos comandos e dos erros se houver.</p>

<h4>Criando tasks</h4>

<p>Vamos começar com um exemplo bem simples de tarefa, um hello world por assim dizer.</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
- name: "Vamos dar echo"
  shell: 'echo teste'
</code></pre>

<p>Lembra no nosso arquivo hosts a separação que fizemos com os colchetes? Use o nome que você definiu lá, aqui na opção hosts.</p>

<p>Em seguida criamos uma tarefa com o nome <strong>Vamos dar echo</strong>. E é isso que ela se dispõe a fazer. Rodando o playbook acima, ele vai acessar as máquinas presente no seu host e executar um <strong>echo teste</strong>.</p>

<p>Reparem que usamos o módulo <strong>shell</strong> do ansible para executar o comando. Vamos falar mais disso depois.</p>

<p>Vamos criar uma nova tarefa, agora usando o módulo <strong>script</strong> do ansible. Você deve ir aninhando as suas tarefas uma abaixo da outra como segue:</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
  - name: "Vamos dar echo"
    shell: 'echo teste'

  - name: "Executar um script"
    script: '/bin/usr/meu.sh'
</code></pre>

<p>Adicionamos a tarefa chamada <strong>Executar um script</strong>, que vai executar o .sh presente no caminho passado.</p>

<h4>Módulos</h4>

<p>Ansible tem vários módulos como você pode conferir na documentação em <a href="http://docs.ansible.com/ansible/modules_by_category.html">http://docs.ansible.com/ansible/modules_by_category.html</a>.</p>

<p>Esses módulos vem para te ajudar a criar tarefas das mais diferentes naturezas que você imaginar. Execução de linhas de comando, criação de arquivos, acesso a repositórios de versionamento, filas (rabbit, sqs, kafka), checar acesso a outras redes, instalação de programas, acesso a Amazon, Azure, Google Cloud, etc. Esses exemplos são poucos. Dê uma boa navegada na página acima para conferir a real gama de facilidades que o ansible nos dá.</p>

<p>Retorne os olhos nas tasks que fizemos acima e veja os módulos em ação. Usamos Shell e Script que fazem parte da categoria <strong>Commands Modules</strong> (<a href="http://docs.ansible.com/ansible/list_of_commands_modules.html">http://docs.ansible.com/ansible/list_of_commands_modules.html</a>).</p>

<p>Para efeitos didáticos, não vamos usar em nossos exemplos aqui módulos muito diferentes e ousados. Mas não se limite! A documentação do Ansible é excelente e fácil de compreender e vai te ajudar com toda certeza.</p>

<h4>Argumentos</h4>

<p>Os módulos podem ter argumentos / parâmetros. Alguns são nativos a todos os módulos do Ansible, outros são específicos. Confira a documentação para ir ficando a par disso.</p>

<pre><code>tasks:
  - name: "Ver se existe a pasta do projeto criada"
    shell: 'mkdir projeto'
    args:
      chdir: '/home'
      creates: 'projeto'
</code></pre>

<p>Aqui com <strong>args</strong>. Usamos <strong>chdir</strong> para dizer aonde queremos executar nossa tarefa.
Também usamos <strong>creates</strong>, que nos ajuda checando se o mkdir vai ser necessário mesmo ou não.</p>

<h4>Variáveis</h4>

<p>Podemos e devemos definir variáveis no topo de nossos playbooks para usá-las em nossas tasks.</p>

<pre><code>---
# Projeto
- hosts: "projeto"

vars:
    repo: git@bitbucket.org/flaviosilveira/primeiro-jogo-html5.git
    document_root: /var/www
    releases_folder: releases

- name: "Clone/Update projeto"
  git: 'repo=ssh://{{repo}} dest={{document_root}}/{{releases_folder}} clone=yes update=yes accept_hostkey=yes force=yes'   
</code></pre>

<p>Usamos as variáveis com seus nomes entre chaves duplas <strong>{{nome_da_variavel}}</strong>.</p>

<p>Repare como se compõe o comando para clonar ou atualizar nosso projeto usando o módulo git do ansible. Esse módulo faz clone se o projeto git não existir na máquina ou atualiza se ele já estiver lá.</p>

<h4>Passando variáveis pela linha de comando</h4>

<p>Você consegue passar variáveis através da chamada do ansible, o que pode te dar ainda mais ideas em suas automações.</p>

<pre><code>ansible-playbook -i hosts projeto.yml -e "env=homologacao"
</code></pre>

<p>Com -e, passamos a variável <strong>env</strong> para nosso playbook. De dentro dele, vamos usar {{env}} para resgatar.</p>

<pre><code>---
# Projeto
- hosts: "projeto-{{env}}"
</code></pre>

<p>Lembram na definição de nossos hosts, quando fizemos uma variação com máquinas de homologação e uma máquina local? Aqui está um uso para essa organização, facilitando em você não ter de ficar alterando seus playbooks todo o tempo.</p>

<h4>Salvando saídas de tarefas como variável</h4>

<p>Outra coisa legal é armazenar saídas de tarefas para variáveis e assim poder usá-las posteriormente.</p>

<pre><code>- name: "Contar pastas"
  shell: 'ls | wc -l'
  args:
    chdir: '{{document_root}}/{{releases_folder}}'
  register: to_remove
</code></pre>

<p>Na tarefa acima, usamos um comando Shell para contar um número de pastas.
Estamos usando argumentos para o módulo e também variáveis. Coisas que já vimos acima.</p>

<p>Em seguida registramos a saída desse comando para a variável <strong>count</strong>.
Para usá-la? {{count}}.</p>

<p>As vezes o que você coloca na variável é um objeto. Confira a saída em verbose (-vvvv) caso tenha problemas usando como acima. Talvez você precise de alternativas:</p>

<pre><code>{{count.stdout}} #Saída do ansible
{{count.stdout | int}} #Mesmo que acima, mas convertendo para inteiro
</code></pre>

<h4>Condicionais</h4>

<p>Uma task pode ser executada ou não baseado em uma condional.</p>

<pre><code>- name: "Remove pastas"
  shell: 'ls -t | tail -n $(($(ls | wc -l)-3)) | xargs rm -rf'
  args:
    chdir: '{{document_root}}/{{releases_folder}}'
  when: '{{count.stdout | int}} &gt; 3'
</code></pre>

<p>Reparem na última linha, no <strong>when</strong>. Se a variável nos trouxer um resultado maior que 3, executaremos a tarefa, caso contrário não.</p>

<p>Para curiosidade, esse comando ordena as pastas por data, e deixa apenas as últimas 3, removendo o restante.</p>

<h4>Ignorando erros</h4>

<p>As vezes algumas tarefas nos trarão erros, mas que por algum motivo não precisamos nos preocupar. Para isso, use <strong>ignore_errors</strong>.</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
  - name: "Vamos dar echo"
    shell: 'echo teste'
    args:
       chdir: '{{document_root}}/{{releases_folder}}'
    ignore_errors: true
</code></pre>

<p>Pronto, erros serão ignorados e seu playbook continuará em execução.</p>

<p>Isso pode ser útil também para algum comando que tem uma saída de comando muito grande. O ansible as vezes considera isso como um erro.</p>

<h4>Usando Includes</h4>

<p>Alguma tarefa que vai ser executada em mais de um playbook? Use Includes.
Crie uma pasta chamada <strong>includes</strong> e dentro dela crie um arquivo chamado <strong>outro.yml</strong>.</p>

<p>Dentro do seu arquivo <strong>outro.yml</strong>, você trabalha como se ele fosse uma tarefa normal</p>

<pre><code>---
# Include responsavel pela criacao da pasta

- name: "Ver se existe a pasta do projeto criada"
  shell: 'mkdir projeto'
  args:
    chdir: '/home'
    creates: 'projeto'
</code></pre>

<p>Para usar o include em outros playbooks faça:</p>

<pre><code>tasks:
  - include: 'includes/outro.yml'
</code></pre>

<p>Quer passar variáveis para seus includes?</p>

<pre><code>tasks:
  - include: 'includes/outro.yml variavel=3 variavel2={{document_root}}'
</code></pre>

<p>Reparem que definimos uma variável no momento de chamar o include e para a variável chamada <strong>variavel2</strong>, usamos uma variável que pode ter sido definida no topo de nosso playbook ou ainda que pode ter vindo da saída de uma task.</p>

<h4>That&rsquo;s It</h4>

<p>É isso por hoje pessoal! Cobrimos aqui o bé-a-bá no ansible, criamos tarefas, definimos nossas máquinas afetadas, aprendemos sobre módulos, argumentos, variáveis e includes.</p>

<p>Exercite em sua infraestrutura. Se não tem uma infraestrutura para testar, experimente com máquinas virtuais ou ainda com containers em Docker, tema que viemos discutindo aqui no Blog recentemente (<a href="http://flaviosilveira.com/2016/comece-com-docker/">http://flaviosilveira.com/2016/comece-com-docker/</a>, <a href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/">http://flaviosilveira.com/2016/docker-php7-e-php-built-in/</a>).</p>

<p>Desperte a automação em você! Grande Abraço!
</p>
]]></content>
  </entry>
  
</feed>
