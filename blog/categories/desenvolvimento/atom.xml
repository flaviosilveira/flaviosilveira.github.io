<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Desenvolvimento | Flávio Silveira]]></title>
  <link href="http://flaviosilveira.com/blog/categories/desenvolvimento/atom.xml" rel="self"/>
  <link href="http://flaviosilveira.com/"/>
  <updated>2016-10-10T00:14:43+00:00</updated>
  <id>http://flaviosilveira.com/</id>
  <author>
    <name><![CDATA[Flávio Silveira]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker, PHP7 E PHP Built In]]></title>
    <link href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/"/>
    <updated>2016-10-10T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/docker-php7-e-php-built-in</id>
    <content type="html"><![CDATA[<p>No artigo anterior (<a href="http://flaviosilveira.com/2016/comece-com-docker/">Comece com Docker!</a>) descrevemos juntos alguns passos iniciais com o Docker. Criamos containers, usamos attached, detached, entramos, saímos, executamos comandos. Se você não está familiarizado a isso, te convido a visitar o artigo.</p>

<p>Sendo repetitivo, meu desejo com esses artigos sobre docker é passar para as pessoas as facilidades que containers nos dão para experimentar tecnologias. Que tal hoje experimentarmos o PHP7? Se você não teve a oportunidade de mexer um pouco com ele o Docker está aqui para facilitar as coisas. E para facilitar ainda mais vamos usar o recurso Built In, presente desde a versão 5.4, que nos traz um servidor web embutido. Assim não vamos precisar instalar nada mais.</p>

<!--more-->


<h3>PHP no DockerHub</h3>

<p>No final do artigo anterior falamos sobre o <a href="https://hub.docker.com/">DockerHUB</a>, repositório oficial de imagens para criarmos nossos containers.</p>

<p>O <a href="https://hub.docker.com/_/php/">PHP tem um reposítorio oficial no Docker hub</a> e é de lá que vamos começar. Nessa página temos várias informações desde o que é PHP até como usar a imagem, contribuir, instalar extensões e etc.</p>

<p>Nos comandos que usamos, fizemos <strong><em>Docker Run</em></strong> que verifica se já temos a imagem em nossa máquina e caso não tenha faz o download dela. Vamos aprender um comando novo.</p>

<pre><code>docker pull php
</code></pre>

<p>Com docker pull vamos fazer apenas o download da imagem, ele não vai iniciar um container para a gente direto como <strong><em>docker run</em></strong> faz, apenas o download.</p>

<p>Nesse comando temos a opção de especificar a versão que queremos do PHP. Não passando nada, vai vir para a gente a última. Exatamente o que estamos querendo aqui certo?</p>

<h3>Subindo Container PHP</h3>

<p>Uma vez que a imagem está em nossa máquina, é hora de rodar o container. Vamos ver em que versão estamos?</p>

<pre><code>docker run php php --version
</code></pre>

<p><strong>Docker run</strong> é nosso comando. <strong>php</strong> é o nome da nossa imagem e em seguida o comando que queremos executar no nosso container, <strong>php &ndash;version</strong>.</p>

<p>Ao final desse comando o container terá subido, executado <strong>php &ndash;version</strong>, mostra uma saída e mata o container. A saída dada para mim na data de hoje foi versão <strong>PHP7.0.11</strong>.</p>

<p>O Container morre, porque o comando que passamos executou e finalizou. Comprovamos isso rodando <strong>docker ps</strong>.</p>

<h3>PHP CLI</h3>

<p>Na mesma pegada, vamos testar o PHP CLI com nosso container. PHP CLI é o php em linha de comando.</p>

<p>Mas antes vamos criar um script php para rodar no CLI. Criei uma pasta chamada <strong>php</strong> no meu diretório de desenvolvimento e dentro dele vou criar um script chamado <strong>spaceship.php</strong>.</p>

<pre><code>&lt;?php

// Testing Spaceship Operator
echo 2 &lt;=&gt; 2; // 0
echo 5 &lt;=&gt; 6; // -1
echo 6 &lt;=&gt; 5; // 1

echo "a" &lt;=&gt; "a"; // 0
echo "a" &lt;=&gt; "b"; // -1
echo "b" &lt;=&gt; "a"; // 1
</code></pre>

<p>O objetivo desse script é simplesmente testarmos o Spaceship, novo operador que veio com o PHP7. Vamos rodar ele em um container?</p>

<pre><code>docker run -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php spaceship.php
</code></pre>

<p><strong>Docker run</strong> é nosso comando. Com <strong>-v</strong> vamos fazer share do nosso diretório da nossa máquina local com um diretório de nosso container. Os dois vão estar espelhados. Com <strong>-w</strong> vamos dizer para nosso container php qual é nosso Working directory, nosso diretório de trabalho. Repare que coloquei o mesmo diretório que em nosso container é equivalente ao diretório em nossa máquina.</p>

<p><strong>php</strong> é o nome da nossa imagem que vai servir de base para nosso container e <strong>php spaceship.php</strong> é nosso comando que vai rodar em nosso working directory.</p>

<p>A saída esperada é <strong>0-110-11</strong>, como nos comentários do script acima.
Já conhecia o Spaceship? Vale uma lida na documentação em <a href="http://php.net/manual/en/migration70.new-features.php">novas features PHP7</a>.</p>

<h3>PHP Built In</h3>

<p>Finalmente, vamos finalizar com o PHP Built In.</p>

<p>Vamos primeiro lembrar como é o comando do PHP Built In. Para consultar o help do PHP Cli podemos fazer</p>

<pre><code>docker run -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php --help
</code></pre>

<p>Com -S maiúsculo, temos o que procuramos:</p>

<pre><code>php -S 127.0.0.1:8080
</code></pre>

<p>Simples não? -S, IP e a porta para acessar.</p>

<p>Dessa vez vou explicar o comando que vamos fazer antes:
<strong>Docker run</strong> que é nosso comando para subir o container. <strong>-p</strong> vai mapear a porta 8080 da nossa máquina para a porta 8080 do container. <strong>-v</strong> como vimos anteriormente vai fazer o share do nosso diretório. <strong>-w</strong> especifica onde vai ser o working directory do container php. <strong>php</strong> é o nome da nossa imagem que vai servir de base para nosso container. E o comando que vamos executar dentro do container será <strong>php -S 0.0.0.0:8080</strong>.</p>

<pre><code>docker run -p 8080:8080 -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php -S 0.0.0.0:8080
</code></pre>

<p>Em meu exemplo eu estou usando uma docker machine que tem um IP <strong>192.168.99.100</strong>, quando passo para o comando do container um IP <strong>0.0.0.0</strong> ele é traduzido para o IP da minha docker machine.</p>

<p>Ao executar o comando, ele vai ficar esperando.</p>

<p>Acesso no navegador o seu IP passando a porta 8080, e acrescente <strong>/spaceship.php</strong>. O mesmo resultado visto anteriormente no terminal, agora está no seu navegador.</p>

<p>Para matar o container basta retornar ao terminal e dar um <strong>CTRL+C</strong>.</p>

<h3>Fechando</h3>

<p>Hoje usamos a imagem do PHP. Para quem nunca havia provado o PHP7, fica a sugestão de fazer esse experimento bem facilmente usando containers e Docker. Aprendemos o comando para simplesmente fazer download de uma imagem e exploramos a imagem do PHP usando CLI e Built In.</p>

<p>Espero que sua cabeça esteja com ideias em cima do que foi passado aqui.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comece Com Docker]]></title>
    <link href="http://flaviosilveira.com/2016/comece-com-docker/"/>
    <updated>2016-10-03T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/comece-com-docker</id>
    <content type="html"><![CDATA[<p>Tenho dois posts envolvendo <a href="https://www.vagrantup.com/">vagrant</a> aqui no blog que ainda são certo sucesso de acessos. <a href="http://flaviosilveira.com/2012/vagrant-facil-e-util">Vagrant Fácil e Útil</a> que dá uma introdução ao Vagrant com um exemplo simples e <a href="http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in/">Vagrant, PuPHPet E PHP Built In</a> que apresenta o PuPHPet como um facilitador para criar ambientes e um experimento com o PHP Built In. O primeiro artigo é de 2012, o segundo de 2013. Passados três anos e vendo a busca disso não diminuir, quero trazer para quem ainda não conhece o <a href="https://www.docker.com/">Docker</a>.</p>

<!--more-->


<h3>Containers VS Virtual Machines</h3>

<p>Muita coisa me anima no Vagrant: ser uma máquina virtual leve, poder deixar minha máquina limpa sem ter que instalar várias coisas, poder trabalhar com várias versões de software com facilidade, se aproximar bastante do ambiente de produção e poder experimentar sem medo.</p>

<p>Não vou entrar aqui na discussão filosófica sobre docker vs vagrant, quero apenas trazer uma alternativa a tudo que eu coloquei acima e, em um futuro, mostrar como o docker pode nos ajudar a experimentar ainda mais novas tecnologias.</p>

<p>Docker trabalha com containers, Vagrant com máquinas virtuais. Qual a diferença se você está começando com tudo isso? Não muita! Você pode pensar no container como uma máquina virtual se você está começando mas tenha em mente que todo o conceito e funcionamento é diferente. Ná prática você vai continuar com um mundo paralelo onde vai poder criar e experimentar suas coisas.</p>

<h3>O velho que é novo</h3>

<p>Containers já existem há algum tempo dentro da nossa área com o que chamavamos de Linux Containers ou LXC. O que aparece com o Docker agora é uma maneira mais fácil de trabalhar com tudo isso e um engajamento da comunidade e das empresas de software gigantesco, trazendo uma gama de várias ferramentas prontas em formato de imagens. Com isso não vamos perder muito tempo com configurações e testar e descobrir tecnologias fica mais fácil.</p>

<p>Marque na agenda para pesquisar sobre libvirt, LXC e a história por trás da criação do Docker na França. Vale a pena!</p>

<h3>Instalação e não só para Linux</h3>

<p>Diferente dos antigos, o docker trouxe maneiras de trabalharmos com containers em qualquer sistema operacional. A maneira como ele faz isso está sempre evoluindo a cada versão. Pesquise como está para o seu sistema operacional.</p>

<p>Eu não vou tratar aqui como instalar o Docker nem sua arquitetura básica, quero ir direto aos pontos mesmo que ainda ficando muito parecido com os primeiros passos da documentação oficial. A ideia é explicar as coisas um pouquinho diferente para quem não pegou da maneira que ficou lá e trazer umas maneiras diferentes de pensar.</p>

<h3>Hello World</h3>

<p>Cada um tem a sua maneira de aprender as coisas, sujiro muito que você descubra a sua. Eu gosto de Hello World, começar do ultra básico e ir evoluindo e tentando entender passo a passo. Vamos fazer juntos e já vou explicando algumas coisas.</p>

<p>O Hello World com docker fica da seguinte maneira. Rode:</p>

<pre><code>docker run hello-world
</code></pre>

<h4>Imagens</h4>

<p>O docker vai buscar uma imagem chamada hello-world. Imagens são a base dos containers, são como um cenário pronto que pode conter um sistema operacional e um conjunto de softwares por exemplo.</p>

<p>Você não tem a imagem localmente, então o docker vai fazer o download dela. Para algumas imagens você vai ver o docker fazendo vários downloads paralelos para deixar as coisas mais rápidas.</p>

<h4>Saída</h4>

<p>Uma vez que foi feito o download da imagem o docker vai subir o container e rodar o programa hello-world sozinho.</p>

<pre><code>Hello from Docker!
This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash
</code></pre>

<p>Se é isso que aparece para você, está feito! Tudo funcionando! O docker já te provoca a tentar algo mais ambicioso e é para esse caminho que vamos:</p>

<h3>CentOS</h3>

<p>A saída do Hello World te desafia a fazer um container Ubuntu. Como muita gente usa Ubuntu como máquina principal, pessoalmente sugiro tentar outra distro no container. Que tal CentOS?</p>

<pre><code>docker run -it centos bash
</code></pre>

<p>Novamente aqui o docker vai buscar por uma imagem, dessa vez do CentOS, se não tiver vai fazer download dela.</p>

<p>Novidades no comando:</p>

<ul>
<li>-i é o comando para interagir, vai manter o STDIN aberto.</li>
<li>-t é para alocar um TTY(Talk to you) que é um terminal.</li>
</ul>


<p>Com a imagem em mãos, o docker vai subir o container e executar o comando bash.</p>

<p>Note que a linha do seu terminal mudou e você deve estar dentro do container. Todo comando que você executar agora está sendo executado dentro do seu container com Ubuntu.</p>

<p>Experimente alguns comandos para comprovar. Por exemplo: <strong>yum</strong>.</p>

<h3>Attached</h3>

<p>Vamos sair do nosso container sem matar ele. Segure CTRL e pressione P e em sequida Q.
Você está de volta para sua máquina principal. Vamos ver os containers que temos rodando?</p>

<pre><code>docker ps
</code></pre>

<p>O comando ps vai nos mostrar os containers que estão rodando com um id, o processo que estão executando, quando foram criados, seu status, portas e nome do container.</p>

<p>Como não passamos nenhum nome para nosso container, o docker deu um de seus nomes padrão.</p>

<p>Vamos voltar para nosso container CentOS? Para isso vamos fazer o seguinte comando:</p>

<pre><code>docker attach [id ou nome do container]
</code></pre>

<p>Com o ID ou nome do container, você consegue voltar para ele, o que chamam de attach.</p>

<p>Pense no Attach como você dentro do container. O padrão quando se cria um container é attach, e foi isso que aconteceu quando passamos o comando run, entramos no container.</p>

<h3>Detach</h3>

<p>De dentro do container, digite exit. Isso vai matar o container e ele não vai existir mais. O mesmo vai acontecer se você fizer um CTRL+C por exemplo.</p>

<pre><code>docker ps -a
</code></pre>

<p>Com o comando acima, além de ver seus containers ativos (se houver) ele mostra também os containers inativos. Se você deu exit em seu container do CentOS, essa mensagem vai ser mostrada em status.</p>

<p>Agora vamos criar o container novamente, mas dessa vez passando uma opção detached, ou seja, vamos criar o container mas não vamos entrar nele. Vamos também dar um nome para nosso container</p>

<pre><code>docker run --name meu-centos -itd centos bash
</code></pre>

<p>Ao rodar docker ps você vê que seu container está rodando, com o comando <strong>bash</strong> e com o nome <strong>meu-centos</strong></p>

<p><strong>Nesse ponto faça o exercício de entrar e sair de containers, criar outros e etc. Use Attach e CTRL+P+Q</strong></p>

<h3>Exec</h3>

<p>As vezes precisamos apenas executar apenas um comando dentro de um container e entrar e sair dele seria muito chato e demorado. Para isso temos o Exec:</p>

<pre><code>docker exec meu-centos echo teste
</code></pre>

<p>Aqui o docker entrou no container, executou o comando <strong>echo teste</strong> em meu-centos e retornou a sua máquina.</p>

<h3>Comandos que você talvez precise</h3>

<pre><code>#Para listar as imagens que você tem: docker images
#Para remover containers: docker rm
#Para remover imagens: docker rmi
#Parar e reiniciar container: docker start / docker stop 
</code></pre>

<h3>Fechando</h3>

<p>Aqui fizemos os pequenos primeiros passos com containers. Muito parecido com o proposto pela documentação oficial.</p>

<p>Te convido a explorar o <a href="https://hub.docker.com/">DockerHUB</a> repositório oficial de imagens para criarmos containers. Procure ferramentas que você já trabalha, ferramentas que você quer experimentar, o uso de containers vai te ajudar a fazer testes rápidos e estudar qualquer coisa.</p>

<p>Com isso acredito que sua cabeça já começe a fervilhar de ideias de para onde podemos ir.
Me comprometo a evoluir esses exemplos aqui nas próximas semanas.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant, PuPHPet E PHP Built In]]></title>
    <link href="http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in/"/>
    <updated>2013-09-15T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in</id>
    <content type="html"><![CDATA[<p>Fala pessoal.<br/>
Hoje trago uma dica simples, talvez sem uma utilidade de pronto, mas que pode ser interessante para algum estudo.</p>




<p><strong>O que é Vagrant?</strong><br/>
Para quem ainda não conhece, Vagrant é uma ferramenta que vem revolucionando os ambientes de desenvolvimento.<br/>
Se você ainda não sabe nada sobre essa ferramenta, confira o post que escrevi aqui no blog: <a href="http://flaviosilveira.com/2012/vagrant-facil-e-util/">http://flaviosilveira.com/2012/vagrant-facil-e-util/</a>.</p>




<!--more-->




<p>Alguns pontos do Vagrant:<br/>
&#8211; Com o Vagrant você não precisa instalar apache e outras ferramentas e poluir sua máquina.<br/>
&#8211; Você pode criar uma máquina virtual para cada projeto e com isso ter uma versão igual ao seu servidor de produção, com a mesma versão de PHP, de MySQL e etc.<br/>
Com isso acaba aquela desculpa de &#8220;Na minha máquina funciona!&#8221;.<br/>
&#8211; Com o Vagrant você pode distribuir o mesmo ambiente para todo seu time de desenvolvimento, evitando funcionamentos diferentes entre pessoas do mesmo time.<br/>
&#8211; Muito mais.</p>




<p><strong>PuPHPet: Arquivos puppet</strong><br/>
Com arquivos puppet (.pp) você pode definir pacotes, programas e extensões a serem instaladas na sua máquina virtual.<br/>
Geralmente são coisas complicadas e sempre acaba surgindo um problema quando são feitos esses arquivos na mão.</p>




<p>Felizmente surge o PuPHPet <a href="https://puphpet.com/">https://puphpet.com/</a>, uma ferramenta online que cria o puppet para você. Você seleciona tudo o que você quer, incluindo pacotes PEAR, pacotes PECL, etc.<br/>
Permite também setar o XDebug, timezone, escolher versão do PHP, do MySQL, incluir o composer, muito mais.</p>




<p>Dê uma atenção especial na opção BOX IP Address. Nesse campo você define o ip da sua máquina virtual.<br/>
É esse IP que você vai digitar no browser da sua máquina e acessar o seu projeto.<br/>
Por padrão o PuPHPet traz o IP 192.168.56.101.</p>




<p><strong>O que é PHP Built In?</strong><br/>
Com a versão 5.4, o PHP trouxe uma novidade para os ambientes de desenvolvimento. O PHP Buitl In.<br/>
É um web server rodando direto em cima do PHP, mas apenas com propósitos de desenvolvimento.<br/>
Com um simples comando você define a porta da onde quer rodar o servidor, e pronto. Sem precisar de Apache, NGinx ou o que for.<br/>
Uma coisa rápida para testar seu projeto. Veja detalhes na documentação: <a href="http://www.php.net/manual/pt_BR/features.commandline.webserver.php">http://www.php.net/manual/pt_BR/features.commandline.webserver.php</a></p>




<p><strong>Mãos a Obra</strong><br/>
Instale a versão mais recente do Vagrant acessando a página de downloads em <a href="http://downloads.vagrantup.com/">http://downloads.vagrantup.com/</a>.<br/>
Uma dica é ter instalado o Virtual Box para que tudo corra bem. A instalação não tem segredos.</p>




<p>Um segundo passo é configurar a sua máquina com a ajuda do PuPHPet <a href="https://puphpet.com/">https://puphpet.com/</a>.<br/>
Escolha no mínimo uma versão 5.4 do PHP. Faça o download do arquivo e posicione onde melhor julgar na sua máquina.</p>




<p>Via console, acesse essa pasta e vamos subir a sua máquina virtual com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant up
</pre>




<p>Esse comando irá fazer o download de tudo que você selecionou de configuração via PuPHPet e deixar a máquina online para você.<br/>
Ao final da configuração, você já é capaz de acessar a sua máquina via porta 80 por exemplo, digite em seu navegador o ip que foi setado no campo BOX IP Address no PuPHPet.</p>




<p>Mas que tal testar essa funcionalidade que veio com o PHP 5.4? Vamos colocar o PHP Built In para rodar.<br/>
Vamos acessar sua máquina virtual via ssh, com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant ssh
</pre>




<p>Caso você precise do root para qualquer coisa, basta colocar um sudo na frente do que precisar.</p>




<p>Vamos configurar um pequeno projeto PHP apenas para ocasião de teste. Por exemplo:</p>




<pre class="brush: bash; title: ; notranslate" title="">cd /var/www
mkdir teste
cd teste
</pre>




<p>Dentro dessa pasta teste que criamos, crie um arquivo PHP simples, com um echo por exemplo.</p>




<p>Você será capaz de acessar isso digitando seu BOX IP/teste, mas, para testar o PHP Built In, entre com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">sudo php -S 192.168.56.101:8080
</pre>




<p>Não esqueça de substituir 192.168.56.101 pelo seu BOX IP.<br/>
8080 é a porta que escolhemos aqui. Você pode definir a porta que quiser, com exceção das que já estão em uso.<br/>
** Qualquer comando executado nessa mesma janela, ou um ctrl+c irá derrubar o server.</p>




<p>Pronto, o PHP Built In está escutando na porta definida.<br/>
Você pode conferir isso abrindo um outro terminal e consultando os listenings com o comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">netstat -ln
</pre>




<p>Lembrando que esse comando pode variar de acordo com a distribuição que você selecionou na sua BOX.</p>




<p>Pronto. Você pode acessar do seu browser o seu BOX IP:PORTA e acessar o seu projeto diretamente, sem barras nem nada.<br/>
Aqui eu acessei <a href="http://192.168.56.101:8080/.">http://192.168.56.101:8080/.</a></p>




<p><strong>Resumindo</strong><br/>
Escrevi esse post apenas como curiosidade. Sei que ele pode não ter nenhuma aplicação prática, mas de repente é uma para o pessoal conhecer o PHP Built In e ver até onde ele vai e porque ele está apenas disponível para desenvolvimento.</p>




<p>Grande Abraço!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant: Fácil E útil]]></title>
    <link href="http://flaviosilveira.com/2012/vagrant-facil-e-util/"/>
    <updated>2012-11-07T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2012/vagrant-facil-e-util</id>
    <content type="html"><![CDATA[<p>Salve pessoal!</p>




<p>Hoje eu quero passar uma dica para fazer você parar com aquela desculpa &#8220;Na minha máquina tá funcionando&#8221;. Para isso vou apresentar para vocês o Vagrant <a href="http://vagrantup.com/">http://vagrantup.com/</a>.</p>




<p>O Vagrant é uma ferramenta que te ajuda na criação da infraestrutura para o seu projeto, usando para isso uma máquina virtual. Mas aí você pensa: &#8220;Uma máquina virtual para cada projeto?? Isso vai dar trabalho&#8221;. A grande jogada é que o Vagrant deixa muita coisa invísivel, deixando com que você se preocupe apenas com seu código. É uma máquina virtual reduzida e portável facilmente. Para cada projeto você pode deixar um ambiente diferente rodando, um com PHP 4, outro com PHP 5, um em Debian outro em CentOS, você escolhe.</p>




<!--more-->




<p><strong><br/>
Instalação</strong></p>




<p>Para criar suas máquinas vituais o Vagrant precisa do Virtual Box, um cliente de máquinas virtuais da Oracle bastante conhecido. Basta instalar! Você não precisa deixar o programa aberto para usar o Vagrant. Você pode fazer o download do Virtual box no seguinte link <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>.</p>




<p>Instalado o Virtual Box, faça o download do Vagrant e o instale. Procure pela versão do seu sistema operacional no seguinte link <a href="http://downloads.vagrantup.com/">http://downloads.vagrantup.com/</a>.</p>




<p><strong><br/>
Configurando e rodando</strong></p>




<p>Outra coisa que o Vagrant utiliza para criar suas máquinas virtuais são Boxes, ou no singular uma Box. Essa Box funciona como uma imagem, uma iso do sistema operacional que você quer instalar. Então antes de qualquer coisa vamos adicionar uma box, para que você a tenha disponível para criar seu primeiro teste com vagrant.</p>




<p>Abra o console do seu sistema operacional, seja o cmd no windows ou o terminal no linux ou mac e entre com o comando</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant box add lucid32 http://files.vagrantup.com/lucid32.box
</pre>




<p>Essa é a box de exemplo que o Quick Start do Vagrant traz para a gente, onde o primeiro parâmetro que vem após add é o nome que estamos dando a nossa box e o segundo o caminho da onde faremos o download. Esse comando vai trazer uma Box do Ubuntu Lucid. Aqui eu recomendo que caso esteja começando com o Vagrant faça um teste usando essa box, mas caso queira avançar um pouco mais, aqui está uma lista de algumas boxes disponíveis por aí <a href="http://www.vagrantbox.es/">http://www.vagrantbox.es/</a>.</p>




<p>Box preparada, que tal colocar nosso ambiente para rodar?</p>




<p>Crie uma pasta para o seu projeto no seu ambiente de trabalho e acesse ela via console.<br/>
Entre com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant init lucid32
</pre>




<p>Caso tenha usado outro nome para a sua box no passo anterior, substitua no lugar de lucid32 no comando acima.</p>




<p>Como o próprio comando se explica, ele prepara uma configuração inicial para você usando um arquivo que ele cria em seu diretório chamada Vagrantfile. Dentro desse arquivo existe algumas configurações como a box a ser usada entre outros.</p>




<p>Agora é só subir o ambiente.</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant up
</pre>




<p>Ao subir o ambiente o vagrant irá realmente criar sua máquina virtual e configurar as coisas para você. Acompanhe as saídas dos comandos para detalhes.</p>




<p>Tudo pronto!</p>




<p><strong><br/>
Testando</strong></p>




<p>Chegou a hora da verdade. Crie um arquivo html com qualquer conteúdo dentro da pasta do seu projeto.</p>




<p>Por exemplo vamos criar um arquivo chamado teste.html com o seguinte conteúdo</p>




<pre class="brush: xml; title: ; notranslate" title="">&lt;h1&gt;Teste&lt;/h1&gt;
</pre>




<p>Agora acesse via browser a pasta do seu projeto e o arquivo que criou.<br/>
<a href="../../assets/uploads/2012/11/imagem1.png"><img class="alignleft size-full wp-image-587" title="Vagrant - Rodando" src="../../assets/uploads/2012/11/imagem1.png" alt="Vagrant - Rodando" width="394" height="101" /></a><br/>
<br style="clear: both;" /><br/>
Esse HTML está dentro da sua máquina virtual e você está rodando a partir do seu localhost. Muito bom não?</p>




<p>Alguns pontos:</p>




<ul>
<li>Note que você nem abriu essa máquina virtual para trabalhar dentro dela. Você está trabalhando como se ela fosse uma pasta local em sua máquina, essa é a beleza da coisa. Você pode deixar isso melhor organizado usando a opção share_folder do arquivo de configuração Vagrantfile</li>
<li>Mostrei aqui um teste com HTML como também é mostrado no Quick Start do Vagrant, mas você pode instalar o que quiser dentro da sua máquina virtual seja PHP, Java, Python e rodar o que bem entender. Apenas atente para fazer direcionamento das portas para que isso funcione de acordo. Veja a opção forward_port do arquivo de configuração Vagrantfile</li>
<li>Detalhes com todas as opções disponíveis para o Vagrantfile você encontra na documentação oficial <a href="http://vagrantup.com/v1/docs/vagrantfile.html">http://vagrantup.com/v1/docs/vagrantfile.html</a></li>
</ul>




<p><strong><br/>
SSH</strong></p>




<p>E que tal um acesso SSH na sua máquina virtual?<br/>
Sim, o Vagrant te traz isso!<br/>
Se você está no Mac ou Unix apenas entre com o comando abaixo e você está dentro.</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant ssh
</pre>




<p>Para usuários do windows será necessário o uso do puttygen, putty e algumas configurações em cima deles. Nada muito complicado para quem já trabalha com SSH no seu dia a dia.</p>




<p>Após acesar o ssh via vagrant, você sai no seu home <em>/home/vagrant</em>.<br/>
Os arquivos que você criou dentro da pasta do seu projeto podem ser encontrados em <em>/vagrant</em>.</p>




<p><strong><br/>
Distribuindo seu ambiente</strong></p>




<p>Está trabalhando com alguém em um projeto? Que tal enviar esse ambiente que você criou no Vagrant para essa pessoa, para que vocês trabalhem em cima do mesmo ambiente?</p>




<p>Para isso basta criar um pacote da sua máquina virtual com o seguinte comando</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant package
</pre>




<p>Ao final do processo você terá um arquivo chamado package.box.<br/>
Para que alguém ou você mesmo o utilize, basta seguir os passos apresentados aqui como se esse arquivo fosse uma box que você vai fazer o download. Sem mais.</p>




<p><strong><br/>
Resumo</strong></p>




<p>Apresentei aqui uma geral sobre o Vagrant, porque ele é útil, porque é interessante usá-lo e etc. Fizemos um exemplo e vimos como distribuir esse ambiente com mais pessoas. Cobri aqui o básico dessa sensacional ferramenta para você configurar o ambiente de seus projetos individualmente.</p>




<p>Você pode ir mais além e criar várias máquinas virtuais que se comunicam entre si e outros. Para isso leia a documentação <a href="http://vagrantup.com/v1/docs/index.html">http://vagrantup.com/v1/docs/index.html</a> e se intere do que mais o Vagrant pode fazer por você.</p>




<p>É isso pessoal.<br/>
Abraços.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primeiros Passos No PHPUnit]]></title>
    <link href="http://flaviosilveira.com/2012/primeiros-passos-no-phpunit/"/>
    <updated>2012-10-14T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2012/primeiros-passos-no-phpunit</id>
    <content type="html"><![CDATA[<p>Fala pessoal!</p>




<p>Hoje vamos cobrir os primeiros passos de uma ferramenta super importante para quem quer avançar no desenvolvimento PHP, o PHPUnit. Não vamos passar aqui pela instalação e configuração dele, sendo que já temos vários artigos sobre isso internet a fora seja lá qual for seu sistema operacional. Eu estarei demonstrando os exemplos aqui no Mac OS X mas você pode seguir normalmente no seu sistema.</p>




<p>Para quem não sabe PHPUnit é um framework que nos ajuda a desenvolver testes unitários em PHP. Esse unitário se refere literalmente a unidade, pequenas partes. Logo, testes unitários são testes para pequenas partes de código. No objetivo geral, testando cada unidade vamos saber se toda nossa aplicação está funcionando corretamente, e se não está, qual parte (unidade) está falhando. Pense em um portal onde uma equipe grande trabalha e tem várias alterações de código diariamente para melhorias e correções. Os testes tem que estar sempre ok antes de algo ir para o ar, uma maneira rápida certeira de conferir se nada foi quebrado no código.</p>




<!--more-->




<p>Após instalar e configurar o PHPUnit a primeira coisa a fazer é testar se está tudo ok.<br/>
Para isso vá até o seu console e digite o comando <em>phpunit</em>.<br/>
A saída esperada é um helper como na imagem abaixo:<br/>
<img class="alignleft size-full wp-image-562" title="phpunit 1" src="../../assets/uploads/2012/10/Imagem1.png" alt="testando phpunit" width="487" height="214" /><br style="clear: both;" /></p>




<p>Caso você tenha problemas é hora de checar a sua instalação.<br/>
Se você usa sistema unix e instalou o PHPUnit via PEAR aqui vão algumas dicas para tentar resolver isso:</p>




<ul>
<li>Pode ser que esteja tudo instalado corretamente, mas o console não esteja localizando o comando do PHPUnit. Para resolver isso primeiro verifique se a PEAR está instalada tentando digitar o comando <em>pear</em>. Se sim, entre com o comando <em>pear config-get bin_dir</em> para saber o diretório do bin do PHPUnit. Confira se a saída está no seu PATH de comandos, com o comando <em>echo $PATH</em>. Caso não esteja use o comando <em>export</em> para adicionar esse caminho.</li>
<li>Se você tem certeza que o PEAR está instalado corretamente, execute o seguinte comando para reinstalar o PHPUnit <em>pear install &#8211;alldeps &#8211;force phpunit/PHPUnit</em>.</li>
</ul>




<p>Com tudo ok podemos seguir em frente.<br/>
Daqui em diante conto que você saiba pelo menos um mínimo de Orientação a Objetos para que acompanhe os exemplos abaixo.<br/>
Para que a gente entenda o que esperar do PHPUnit, vamos primeiro criar uma classe com pelo menos um atributo e seus métodos <em>get()</em> e <em>set()</em>.<br/>
Que tal a tradicional classe Carro com uma propiedade de cor?</p>




<pre class="brush: php; title: ; notranslate" title="">/**
 * Classe Carro
 *
 **/
class Carro
{
    private $_cor;

    public function getCor()
    {
        return $this-&gt;_cor;
    }

    public function setCor($cor)
    {
        $this-&gt;_cor = $cor;
    }

}
</pre>




<p>Com a classe principal criada vamos agora preparar nossa classe de testes.<br/>
Vamos chamar nossa classe de testes de CarroTeste.php.</p>




<pre class="brush: php; title: ; notranslate" title="">require_once "Carro.php";

/**
 * Classe Carro Teste
 **/
class CarroTeste extends PHPUnit_Framework_Testcase
{

}
</pre>




<p>Repare em duas coisas no código acima:</p>




<ul>
<li>Sua classe de testes deve conhecer a classe que vai ser testada (use require, include ou autoload).</li>
<li>Sua classe de testes precisa extender o framework PHP_Unit. Para extender o PHPUnit da mesma forma como no código acima, configure corretamente o seu <em>include_path</em> no seu arquivo de configuração do PHP (php.ini). Não sabe onde está seu arquivo php.ini? Utilize o comando <em>php &#8211;ini</em>. Procure por <em>include_path</em> dentro desse arquivo e adicione o caminho para o framework PHPUnit. <em>**A instalação via PEAR constuma adicionar esse caminho para você no php.ini. Confira o arquivo se for caso.</em></li>
</ul>




<p>Finalmente vamos ao nosso teste em si. Vamos testar se nossos métodos <em>get()</em> e <em>set()</em> estão realmente fazendo o que se espera. <em>Get()</em> tem de retornar o mesmo valor passado para <em>set()</em>. Para verificar isso vamos usar o método assertEquals do PHPUnit, veja o exemplo:</p>




<pre class="brush: php; title: ; notranslate" title="">require_once "Carro.php";

/**
 * Classe Carro Teste
 **/
class CarroTeste extends PHPUnit_Framework_Testcase
{
    public function testeCor()
    {
        $carro = new Carro();
        $carro-&gt;setCor("Azul");

        $this-&gt;assertEquals("Azul", $carro-&gt;getCor());
    }
}
</pre>




<p>Criamos um método testeCor em nossa classe de testes.<br/>
Dentro dele instanciamos a classe carro e atribuímos para a propiedade cor o valor Azul.<br/>
O método AssertEquals do PHPUnit vai comparar se os dois parâmetros passados são iguais.</p>




<p>Vamos rodar nosso teste?<br/>
Em seu console execute o comando phpunit passando para ele o caminho da sua classe de testes. O resultado deve ser similar a esse:<br/>
<img class="alignleft size-full wp-image-563" title="Imagem2" src="../../assets/uploads/2012/10/Imagem2.png" alt="Rodando o primeiro teste" width="442" height="171" /><br style="clear: both;" /></p>




<p>Na imagem você percebe abaixo da linha de descrição da versão do PHPUnit um . (ponto). Em seguida uma descrição do tempo de execução e memória utilizada e abaixo um OK. Isso indica que nosso teste teve sucesso. O ponto que falamos acima indica que um teste teve sucesso, em caso de falha teremos um F no lugar do ponto. Para cada teste irá ser adicionado um <em>. ponto</em>ou um <em>F</em>.</p>




<p>Vamos forçar um erro no teste para ver o que acontece? Vamos trocar os parâmetros do nosso <em>AssertEquals</em> e dizer que estamos esperando o resultado <em>Amarelo</em> invés de <em>Azul</em>.</p>




<pre class="brush: php; title: ; notranslate" title="">require_once "Carro.php";

/**
 * Classe Carro Teste
 **/
class CarroTeste extends PHPUnit_Framework_Testcase
{
    public function testeCor()
    {
        $carro = new Carro();
        $carro-&gt;setCor("Azul");

        $this-&gt;assertEquals("Amarelo", $carro-&gt;getCor());
    }
}
</pre>




<p>Rodando nosso teste agora temos a seguinte saída:<br/>
<img class="alignleft size-full wp-image-564" title="Imagem3" src="../../assets/uploads/2012/10/Imagem3.png" alt="Falha no PHPUnit" width="427" height="317" /><br style="clear: both;" /><br/>
No lugar do ponto anterior que indicava sucesso, temos agora um <em>F</em> indicando a falha. Junto a isso o PHPUnit nos traz detalhes da falha com o nome do teste que falhou, o que era esperado e o que foi retornado.</p>




<p>A ideia por trás do PHPUnit e suas funções é bem similar ao que foi demonstrado acima, com o detalhe que algumas funções podem ter mais parâmetros ou esperar tipos diferentes de dados. Que tal descobrir mais métodos do PHPUnit e criar novos testes? Visite o capítulo 4 do manual do PHPUnit e teste outras funções do framework. Segue o link para o manual: <a href="http://www.phpunit.de/manual/current/en/writing-tests-for-phpunit.html" title="PHPUnit Manual Cap4">http://www.phpunit.de/manual/current/en/writing-tests-for-phpunit.html</a>.</p>




<p>Grande Abraço!</p>

]]></content>
  </entry>
  
</feed>
