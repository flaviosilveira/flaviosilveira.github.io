<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Desenvolvimento | Flávio Silveira]]></title>
  <link href="http://flaviosilveira.com/blog/categories/desenvolvimento/atom.xml" rel="self"/>
  <link href="http://flaviosilveira.com/"/>
  <updated>2016-10-23T18:38:10+00:00</updated>
  <id>http://flaviosilveira.com/</id>
  <author>
    <name><![CDATA[Flávio Silveira]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ansible - Desperte a Automação Em Você]]></title>
    <link href="http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce/"/>
    <updated>2016-10-17T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/ansible-desperte-a-automacao-em-voce</id>
    <content type="html"><![CDATA[<p>
Automação vem se tornando um tema essencial em empresas que querem crescer com mais cérebro e menos braço. Aquela tarefa que você repete mais de duas vezes já deve ser pensada em uma maneira de ser automática, concorda?</p>

<p>No universo do desenvolvimento, quantas são as tarefas que repetimos quando se trata de máquinas? Deploys, extração de logs, instalação e configuração de ferramentas, etc. Ansible pode ser a ferramenta que vai te ajudar a automatizar tudo isso.</p>

<!--more-->


<p>Durante esse ano de 2016 apresentei a palestra <strong><em>Automações com Ansible</em></strong> onde o objetivo principal foi uma iniciação ao Ansible. Como usar ele de maneira bem básica e se iniciar na automação. Estrutura de um projeto básico, como criar as primeiras tarefas, passar argumentos, variáveis, e usar includes. Essa vai ser a agenda desse longo post técnico e assim também encerrando as apresentações dessa palestra para dar lugar a outras :-).</p>

<h4>Ansible</h4>

<p>Ansible (<a href="https://www.ansible.com/">https://www.ansible.com/</a>) é uma ferramenta Open Source em Python para automatizar ações em máquinas. Ela é super simples, e esse é sempre um dos meus lemas quando se trata de desenvolvimento e tecnologia. Se está difícil, tem alguma coisa errada. Pare e analise. Tecnologia não é mágica, tem que fazer sentido.</p>

<p>Não vou falar da instalação do Ansible. É fácil você fazer download dele e sair rodando ou ainda usar <strong>yum install</strong> ou <strong>apt-get install</strong>.</p>

<h4>Um projeto básico</h4>

<p>Há várias maneiras de estruturar um projeto ansible. Algumas sugestão com arquiteturas de pastas super elaboradas, onde podem fazer sentido para algumas soluções. Para agora, para começarmos, dois arquivos vão resolver nosso problema.</p>

<pre><code>- projeto.yml
- hosts
</code></pre>

<p>Um arquivo com extensão .yml (yet another markup language) e um arquivo hosts, sem extensão.
No arquivo yml você vai colocar o passo a passo da sua automação. Tecnicamente ele tem o nome de playbook. No arquivo hosts vamos apontar as máquinas onde as tarefas serão executadas.</p>

<h4>Arquivo hosts</h4>

<p>Vamos primeiro configurar as máquinas que serão afetadas pelas nossas tarefas.</p>

<pre><code>#This is the Host File.

[projeto]
192.168.5.6 ansible_ssh_user=user ansible_ssh_pass=pass
</code></pre>

<p>É isso que vocês precisam no arquivo hosts quando falamos de acesso que o ansible vai fazer usando ssh. O IP da máquina, seguido de um usuário e senha. Esse nome em colchetes vai te ajudar a gerenciar as coisas em um futuro, mantenha ele ali.</p>

<p>Vai fazer uso de portas? Acesso a máquinas com chave? Chamar mais de uma máquina?</p>

<pre><code>#This is the Host File.

###################
# Projeto servers #
###################
[projeto-homologacao]
222.222.222.222:2123 ansible_ssh_private_key_file=/.ssh/chave.pem ansible_ssh_pass=pass
123.123.123.123:2123 ansible_ssh_private_key_file=/.ssh/chave.pem ansible_ssh_pass=pass

[projeto-local]
192.168.5.6 ansible_ssh_user=user ansible_ssh_pass=pass
</code></pre>

<p>Para acessar as máquinas usando chaves use <strong>ansible_ssh_private_key_file</strong>. Se seu acesso tem portas diferentes, basta adicionar elas ao final do IP.</p>

<p>Notem que fiz uma separação entre as máquinas de homologação e a máquina local. Essa organização pode te ajudar no futuro a gerenciar essas máquinas e usar isso em suas automações.</p>

<h4>Rodando o Ansible</h4>

<p>Para rodar o ansible o comando é fácil</p>

<pre><code>ansible-playbook -i hosts projeto.yml
</code></pre>

<p>Ansible-playbook é o comando. -i  é o parâmetro que significa inventory, para inventário, onde passaremos nosso arquivo hosts. Por último nosso arquivo de tarefas. Sim! Não temos nenhuma tarefa, já vamos chegar lá.</p>

<p>Caso precise rodar o ansible com mais saidas de log, em um momento para resolver problemas por exemplo, você pode usar -v, de verbose.</p>

<pre><code>ansible-playbook -i hosts projeto.yml -v
ansible-playbook -i hosts projeto.yml -vv
ansible-playbook -i hosts projeto.yml -vvv
ansible-playbook -i hosts projeto.yml -vvvv
</code></pre>

<p>As opções vão até 4 Vs. Onde cada um a mais, te mostra mais detalhes dos comandos e dos erros se houver.</p>

<h4>Criando tasks</h4>

<p>Vamos começar com um exemplo bem simples de tarefa, um hello world por assim dizer.</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
- name: "Vamos dar echo"
  shell: 'echo teste'
</code></pre>

<p>Lembra no nosso arquivo hosts a separação que fizemos com os colchetes? Use o nome que você definiu lá, aqui na opção hosts.</p>

<p>Em seguida criamos uma tarefa com o nome <strong>Vamos dar echo</strong>. E é isso que ela se dispõe a fazer. Rodando o playbook acima, ele vai acessar as máquinas presente no seu host e executar um <strong>echo teste</strong>.</p>

<p>Reparem que usamos o módulo <strong>shell</strong> do ansible para executar o comando. Vamos falar mais disso depois.</p>

<p>Vamos criar uma nova tarefa, agora usando o módulo <strong>script</strong> do ansible. Você deve ir aninhando as suas tarefas uma abaixo da outra como segue:</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
  - name: "Vamos dar echo"
    shell: 'echo teste'

  - name: "Executar um script"
    script: '/bin/usr/meu.sh'
</code></pre>

<p>Adicionamos a tarefa chamada <strong>Executar um script</strong>, que vai executar o .sh presente no caminho passado.</p>

<h4>Módulos</h4>

<p>Ansible tem vários módulos como você pode conferir na documentação em <a href="http://docs.ansible.com/ansible/modules_by_category.html">http://docs.ansible.com/ansible/modules_by_category.html</a>.</p>

<p>Esses módulos vem para te ajudar a criar tarefas das mais diferentes naturezas que você imaginar. Execução de linhas de comando, criação de arquivos, acesso a repositórios de versionamento, filas (rabbit, sqs, kafka), checar acesso a outras redes, instalação de programas, acesso a Amazon, Azure, Google Cloud, etc. Esses exemplos são poucos. Dê uma boa navegada na página acima para conferir a real gama de facilidades que o ansible nos dá.</p>

<p>Retorne os olhos nas tasks que fizemos acima e veja os módulos em ação. Usamos Shell e Script que fazem parte da categoria <strong>Commands Modules</strong> (<a href="http://docs.ansible.com/ansible/list_of_commands_modules.html">http://docs.ansible.com/ansible/list_of_commands_modules.html</a>).</p>

<p>Para efeitos didáticos, não vamos usar em nossos exemplos aqui módulos muito diferentes e ousados. Mas não se limite! A documentação do Ansible é excelente e fácil de compreender e vai te ajudar com toda certeza.</p>

<h4>Argumentos</h4>

<p>Os módulos podem ter argumentos / parâmetros. Alguns são nativos a todos os módulos do Ansible, outros são específicos. Confira a documentação para ir ficando a par disso.</p>

<pre><code>tasks:
  - name: "Ver se existe a pasta do projeto criada"
    shell: 'mkdir projeto'
    args:
      chdir: '/home'
      creates: 'projeto'
</code></pre>

<p>Aqui com <strong>args</strong>. Usamos <strong>chdir</strong> para dizer aonde queremos executar nossa tarefa.
Também usamos <strong>creates</strong>, que nos ajuda checando se o mkdir vai ser necessário mesmo ou não.</p>

<h4>Variáveis</h4>

<p>Podemos e devemos definir variáveis no topo de nossos playbooks para usá-las em nossas tasks.</p>

<pre><code>---
# Projeto
- hosts: "projeto"

vars:
    repo: git@bitbucket.org/flaviosilveira/primeiro-jogo-html5.git
    document_root: /var/www
    releases_folder: releases

- name: "Clone/Update projeto"
  git: 'repo=ssh://{{repo}} dest={{document_root}}/{{releases_folder}} clone=yes update=yes accept_hostkey=yes force=yes'   
</code></pre>

<p>Usamos as variáveis com seus nomes entre chaves duplas <strong>{{nome_da_variavel}}</strong>.</p>

<p>Repare como se compõe o comando para clonar ou atualizar nosso projeto usando o módulo git do ansible. Esse módulo faz clone se o projeto git não existir na máquina ou atualiza se ele já estiver lá.</p>

<h4>Passando variáveis pela linha de comando</h4>

<p>Você consegue passar variáveis através da chamada do ansible, o que pode te dar ainda mais ideas em suas automações.</p>

<pre><code>ansible-playbook -i hosts projeto.yml -e "env=homologacao"
</code></pre>

<p>Com -e, passamos a variável <strong>env</strong> para nosso playbook. De dentro dele, vamos usar {{env}} para resgatar.</p>

<pre><code>---
# Projeto
- hosts: "projeto-{{env}}"
</code></pre>

<p>Lembram na definição de nossos hosts, quando fizemos uma variação com máquinas de homologação e uma máquina local? Aqui está um uso para essa organização, facilitando em você não ter de ficar alterando seus playbooks todo o tempo.</p>

<h4>Salvando saídas de tarefas como variável</h4>

<p>Outra coisa legal é armazenar saídas de tarefas para variáveis e assim poder usá-las posteriormente.</p>

<pre><code>- name: "Contar pastas"
  shell: 'ls | wc -l'
  args:
    chdir: '{{document_root}}/{{releases_folder}}'
  register: to_remove
</code></pre>

<p>Na tarefa acima, usamos um comando Shell para contar um número de pastas.
Estamos usando argumentos para o módulo e também variáveis. Coisas que já vimos acima.</p>

<p>Em seguida registramos a saída desse comando para a variável <strong>count</strong>.
Para usá-la? {{count}}.</p>

<p>As vezes o que você coloca na variável é um objeto. Confira a saída em verbose (-vvvv) caso tenha problemas usando como acima. Talvez você precise de alternativas:</p>

<pre><code>{{count.stdout}} #Saída do ansible
{{count.stdout | int}} #Mesmo que acima, mas convertendo para inteiro
</code></pre>

<h4>Condicionais</h4>

<p>Uma task pode ser executada ou não baseado em uma condional.</p>

<pre><code>- name: "Remove pastas"
  shell: 'ls -t | tail -n $(($(ls | wc -l)-3)) | xargs rm -rf'
  args:
    chdir: '{{document_root}}/{{releases_folder}}'
  when: '{{count.stdout | int}} &gt; 3'
</code></pre>

<p>Reparem na última linha, no <strong>when</strong>. Se a variável nos trouxer um resultado maior que 3, executaremos a tarefa, caso contrário não.</p>

<p>Para curiosidade, esse comando ordena as pastas por data, e deixa apenas as últimas 3, removendo o restante.</p>

<h4>Ignorando erros</h4>

<p>As vezes algumas tarefas nos trarão erros, mas que por algum motivo não precisamos nos preocupar. Para isso, use <strong>ignore_errors</strong>.</p>

<pre><code>--
# Projeto
- hosts: "projeto"

tasks:
  - name: "Vamos dar echo"
    shell: 'echo teste'
    args:
       chdir: '{{document_root}}/{{releases_folder}}'
    ignore_errors: true
</code></pre>

<p>Pronto, erros serão ignorados e seu playbook continuará em execução.</p>

<p>Isso pode ser útil também para algum comando que tem uma saída de comando muito grande. O ansible as vezes considera isso como um erro.</p>

<h4>Usando Includes</h4>

<p>Alguma tarefa que vai ser executada em mais de um playbook? Use Includes.
Crie uma pasta chamada <strong>includes</strong> e dentro dela crie um arquivo chamado <strong>outro.yml</strong>.</p>

<p>Dentro do seu arquivo <strong>outro.yml</strong>, você trabalha como se ele fosse uma tarefa normal</p>

<pre><code>---
# Include responsavel pela criacao da pasta

- name: "Ver se existe a pasta do projeto criada"
  shell: 'mkdir projeto'
  args:
    chdir: '/home'
    creates: 'projeto'
</code></pre>

<p>Para usar o include em outros playbooks faça:</p>

<pre><code>tasks:
  - include: 'includes/outro.yml'
</code></pre>

<p>Quer passar variáveis para seus includes?</p>

<pre><code>tasks:
  - include: 'includes/outro.yml variavel=3 variavel2={{document_root}}'
</code></pre>

<p>Reparem que definimos uma variável no momento de chamar o include e para a variável chamada <strong>variavel2</strong>, usamos uma variável que pode ter sido definida no topo de nosso playbook ou ainda que pode ter vindo da saída de uma task.</p>

<h4>That&rsquo;s It</h4>

<p>É isso por hoje pessoal! Cobrimos aqui o bé-a-bá no ansible, criamos tarefas, definimos nossas máquinas afetadas, aprendemos sobre módulos, argumentos, variáveis e includes.</p>

<p>Exercite em sua infraestrutura. Se não tem uma infraestrutura para testar, experimente com máquinas virtuais ou ainda com containers em Docker, tema que viemos discutindo aqui no Blog recentemente (<a href="http://flaviosilveira.com/2016/comece-com-docker/">http://flaviosilveira.com/2016/comece-com-docker/</a>, <a href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/">http://flaviosilveira.com/2016/docker-php7-e-php-built-in/</a>).</p>

<p>Desperte a automação em você! Grande Abraço!
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker, PHP7 E PHP Built In]]></title>
    <link href="http://flaviosilveira.com/2016/docker-php7-e-php-built-in/"/>
    <updated>2016-10-10T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/docker-php7-e-php-built-in</id>
    <content type="html"><![CDATA[<p>No artigo anterior (<a href="http://flaviosilveira.com/2016/comece-com-docker/">Comece com Docker!</a>) descrevemos juntos alguns passos iniciais com o Docker. Criamos containers, usamos attached, detached, entramos, saímos, executamos comandos. Se você não está familiarizado a isso, te convido a visitar o artigo.</p>

<p>Sendo repetitivo, meu desejo com esses artigos sobre docker é passar para as pessoas as facilidades que containers nos dão para experimentar tecnologias. Que tal hoje experimentarmos o PHP7? Se você não teve a oportunidade de mexer um pouco com ele o Docker está aqui para facilitar as coisas. E para facilitar ainda mais vamos usar o recurso Built In, presente desde a versão 5.4, que nos traz um servidor web embutido. Assim não vamos precisar instalar nada mais.</p>

<!--more-->


<h3>PHP no DockerHub</h3>

<p>No final do artigo anterior falamos sobre o <a href="https://hub.docker.com/">DockerHUB</a>, repositório oficial de imagens para criarmos nossos containers.</p>

<p>O <a href="https://hub.docker.com/_/php/">PHP tem um reposítorio oficial no Docker hub</a> e é de lá que vamos começar. Nessa página temos várias informações desde o que é PHP até como usar a imagem, contribuir, instalar extensões e etc.</p>

<p>Nos comandos que usamos, fizemos <strong><em>Docker Run</em></strong> que verifica se já temos a imagem em nossa máquina e caso não tenha faz o download dela. Vamos aprender um comando novo.</p>

<pre><code>docker pull php
</code></pre>

<p>Com docker pull vamos fazer apenas o download da imagem, ele não vai iniciar um container para a gente direto como <strong><em>docker run</em></strong> faz, apenas o download.</p>

<p>Nesse comando temos a opção de especificar a versão que queremos do PHP. Não passando nada, vai vir para a gente a última. Exatamente o que estamos querendo aqui certo?</p>

<h3>Subindo Container PHP</h3>

<p>Uma vez que a imagem está em nossa máquina, é hora de rodar o container. Vamos ver em que versão estamos?</p>

<pre><code>docker run php php --version
</code></pre>

<p><strong>Docker run</strong> é nosso comando. <strong>php</strong> é o nome da nossa imagem e em seguida o comando que queremos executar no nosso container, <strong>php &ndash;version</strong>.</p>

<p>Ao final desse comando o container terá subido, executado <strong>php &ndash;version</strong>, mostra uma saída e mata o container. A saída dada para mim na data de hoje foi versão <strong>PHP7.0.11</strong>.</p>

<p>O Container morre, porque o comando que passamos executou e finalizou. Comprovamos isso rodando <strong>docker ps</strong>.</p>

<h3>PHP CLI</h3>

<p>Na mesma pegada, vamos testar o PHP CLI com nosso container. PHP CLI é o php em linha de comando.</p>

<p>Mas antes vamos criar um script php para rodar no CLI. Criei uma pasta chamada <strong>php</strong> no meu diretório de desenvolvimento e dentro dele vou criar um script chamado <strong>spaceship.php</strong>.</p>

<pre><code>&lt;?php

// Testing Spaceship Operator
echo 2 &lt;=&gt; 2; // 0
echo 5 &lt;=&gt; 6; // -1
echo 6 &lt;=&gt; 5; // 1

echo "a" &lt;=&gt; "a"; // 0
echo "a" &lt;=&gt; "b"; // -1
echo "b" &lt;=&gt; "a"; // 1
</code></pre>

<p>O objetivo desse script é simplesmente testarmos o Spaceship, novo operador que veio com o PHP7. Vamos rodar ele em um container?</p>

<pre><code>docker run -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php spaceship.php
</code></pre>

<p><strong>Docker run</strong> é nosso comando. Com <strong>-v</strong> vamos fazer share do nosso diretório da nossa máquina local com um diretório de nosso container. Os dois vão estar espelhados. Com <strong>-w</strong> vamos dizer para nosso container php qual é nosso Working directory, nosso diretório de trabalho. Repare que coloquei o mesmo diretório que em nosso container é equivalente ao diretório em nossa máquina.</p>

<p><strong>php</strong> é o nome da nossa imagem que vai servir de base para nosso container e <strong>php spaceship.php</strong> é nosso comando que vai rodar em nosso working directory.</p>

<p>A saída esperada é <strong>0-110-11</strong>, como nos comentários do script acima.
Já conhecia o Spaceship? Vale uma lida na documentação em <a href="http://php.net/manual/en/migration70.new-features.php">novas features PHP7</a>.</p>

<h3>PHP Built In</h3>

<p>Finalmente, vamos finalizar com o PHP Built In.</p>

<p>Vamos primeiro lembrar como é o comando do PHP Built In. Para consultar o help do PHP Cli podemos fazer</p>

<pre><code>docker run -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php --help
</code></pre>

<p>Com -S maiúsculo, temos o que procuramos:</p>

<pre><code>php -S 127.0.0.1:8080
</code></pre>

<p>Simples não? -S, IP e a porta para acessar.</p>

<p>Dessa vez vou explicar o comando que vamos fazer antes:
<strong>Docker run</strong> que é nosso comando para subir o container. <strong>-p</strong> vai mapear a porta 8080 da nossa máquina para a porta 8080 do container. <strong>-v</strong> como vimos anteriormente vai fazer o share do nosso diretório. <strong>-w</strong> especifica onde vai ser o working directory do container php. <strong>php</strong> é o nome da nossa imagem que vai servir de base para nosso container. E o comando que vamos executar dentro do container será <strong>php -S 0.0.0.0:8080</strong>.</p>

<pre><code>docker run -p 8080:8080 -v ~/dev/php:/usr/src/wd -w /usr/src/wd php php -S 0.0.0.0:8080
</code></pre>

<p>Em meu exemplo eu estou usando uma docker machine que tem um IP <strong>192.168.99.100</strong>, quando passo para o comando do container um IP <strong>0.0.0.0</strong> ele é traduzido para o IP da minha docker machine.</p>

<p>Ao executar o comando, ele vai ficar esperando.</p>

<p>Acesso no navegador o seu IP passando a porta 8080, e acrescente <strong>/spaceship.php</strong>. O mesmo resultado visto anteriormente no terminal, agora está no seu navegador.</p>

<p>Para matar o container basta retornar ao terminal e dar um <strong>CTRL+C</strong>.</p>

<h3>Fechando</h3>

<p>Hoje usamos a imagem do PHP. Para quem nunca havia provado o PHP7, fica a sugestão de fazer esse experimento bem facilmente usando containers e Docker. Aprendemos o comando para simplesmente fazer download de uma imagem e exploramos a imagem do PHP usando CLI e Built In.</p>

<p>Espero que sua cabeça esteja com ideias em cima do que foi passado aqui.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comece Com Docker]]></title>
    <link href="http://flaviosilveira.com/2016/comece-com-docker/"/>
    <updated>2016-10-03T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2016/comece-com-docker</id>
    <content type="html"><![CDATA[<p>Tenho dois posts envolvendo <a href="https://www.vagrantup.com/">vagrant</a> aqui no blog que ainda são certo sucesso de acessos. <a href="http://flaviosilveira.com/2012/vagrant-facil-e-util">Vagrant Fácil e Útil</a> que dá uma introdução ao Vagrant com um exemplo simples e <a href="http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in/">Vagrant, PuPHPet E PHP Built In</a> que apresenta o PuPHPet como um facilitador para criar ambientes e um experimento com o PHP Built In. O primeiro artigo é de 2012, o segundo de 2013. Passados três anos e vendo a busca disso não diminuir, quero trazer para quem ainda não conhece o <a href="https://www.docker.com/">Docker</a>.</p>

<!--more-->


<h3>Containers VS Virtual Machines</h3>

<p>Muita coisa me anima no Vagrant: ser uma máquina virtual leve, poder deixar minha máquina limpa sem ter que instalar várias coisas, poder trabalhar com várias versões de software com facilidade, se aproximar bastante do ambiente de produção e poder experimentar sem medo.</p>

<p>Não vou entrar aqui na discussão filosófica sobre docker vs vagrant, quero apenas trazer uma alternativa a tudo que eu coloquei acima e, em um futuro, mostrar como o docker pode nos ajudar a experimentar ainda mais novas tecnologias.</p>

<p>Docker trabalha com containers, Vagrant com máquinas virtuais. Qual a diferença se você está começando com tudo isso? Não muita! Você pode pensar no container como uma máquina virtual se você está começando mas tenha em mente que todo o conceito e funcionamento é diferente. Ná prática você vai continuar com um mundo paralelo onde vai poder criar e experimentar suas coisas.</p>

<h3>O velho que é novo</h3>

<p>Containers já existem há algum tempo dentro da nossa área com o que chamavamos de Linux Containers ou LXC. O que aparece com o Docker agora é uma maneira mais fácil de trabalhar com tudo isso e um engajamento da comunidade e das empresas de software gigantesco, trazendo uma gama de várias ferramentas prontas em formato de imagens. Com isso não vamos perder muito tempo com configurações e testar e descobrir tecnologias fica mais fácil.</p>

<p>Marque na agenda para pesquisar sobre libvirt, LXC e a história por trás da criação do Docker na França. Vale a pena!</p>

<h3>Instalação e não só para Linux</h3>

<p>Diferente dos antigos, o docker trouxe maneiras de trabalharmos com containers em qualquer sistema operacional. A maneira como ele faz isso está sempre evoluindo a cada versão. Pesquise como está para o seu sistema operacional.</p>

<p>Eu não vou tratar aqui como instalar o Docker nem sua arquitetura básica, quero ir direto aos pontos mesmo que ainda ficando muito parecido com os primeiros passos da documentação oficial. A ideia é explicar as coisas um pouquinho diferente para quem não pegou da maneira que ficou lá e trazer umas maneiras diferentes de pensar.</p>

<h3>Hello World</h3>

<p>Cada um tem a sua maneira de aprender as coisas, sujiro muito que você descubra a sua. Eu gosto de Hello World, começar do ultra básico e ir evoluindo e tentando entender passo a passo. Vamos fazer juntos e já vou explicando algumas coisas.</p>

<p>O Hello World com docker fica da seguinte maneira. Rode:</p>

<pre><code>docker run hello-world
</code></pre>

<h4>Imagens</h4>

<p>O docker vai buscar uma imagem chamada hello-world. Imagens são a base dos containers, são como um cenário pronto que pode conter um sistema operacional e um conjunto de softwares por exemplo.</p>

<p>Você não tem a imagem localmente, então o docker vai fazer o download dela. Para algumas imagens você vai ver o docker fazendo vários downloads paralelos para deixar as coisas mais rápidas.</p>

<h4>Saída</h4>

<p>Uma vez que foi feito o download da imagem o docker vai subir o container e rodar o programa hello-world sozinho.</p>

<pre><code>Hello from Docker!
This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash
</code></pre>

<p>Se é isso que aparece para você, está feito! Tudo funcionando! O docker já te provoca a tentar algo mais ambicioso e é para esse caminho que vamos:</p>

<h3>CentOS</h3>

<p>A saída do Hello World te desafia a fazer um container Ubuntu. Como muita gente usa Ubuntu como máquina principal, pessoalmente sugiro tentar outra distro no container. Que tal CentOS?</p>

<pre><code>docker run -it centos bash
</code></pre>

<p>Novamente aqui o docker vai buscar por uma imagem, dessa vez do CentOS, se não tiver vai fazer download dela.</p>

<p>Novidades no comando:</p>

<ul>
<li>-i é o comando para interagir, vai manter o STDIN aberto.</li>
<li>-t é para alocar um TTY(Talk to you) que é um terminal.</li>
</ul>


<p>Com a imagem em mãos, o docker vai subir o container e executar o comando bash.</p>

<p>Note que a linha do seu terminal mudou e você deve estar dentro do container. Todo comando que você executar agora está sendo executado dentro do seu container com Ubuntu.</p>

<p>Experimente alguns comandos para comprovar. Por exemplo: <strong>yum</strong>.</p>

<h3>Attached</h3>

<p>Vamos sair do nosso container sem matar ele. Segure CTRL e pressione P e em sequida Q.
Você está de volta para sua máquina principal. Vamos ver os containers que temos rodando?</p>

<pre><code>docker ps
</code></pre>

<p>O comando ps vai nos mostrar os containers que estão rodando com um id, o processo que estão executando, quando foram criados, seu status, portas e nome do container.</p>

<p>Como não passamos nenhum nome para nosso container, o docker deu um de seus nomes padrão.</p>

<p>Vamos voltar para nosso container CentOS? Para isso vamos fazer o seguinte comando:</p>

<pre><code>docker attach [id ou nome do container]
</code></pre>

<p>Com o ID ou nome do container, você consegue voltar para ele, o que chamam de attach.</p>

<p>Pense no Attach como você dentro do container. O padrão quando se cria um container é attach, e foi isso que aconteceu quando passamos o comando run, entramos no container.</p>

<h3>Detach</h3>

<p>De dentro do container, digite exit. Isso vai matar o container e ele não vai existir mais. O mesmo vai acontecer se você fizer um CTRL+C por exemplo.</p>

<pre><code>docker ps -a
</code></pre>

<p>Com o comando acima, além de ver seus containers ativos (se houver) ele mostra também os containers inativos. Se você deu exit em seu container do CentOS, essa mensagem vai ser mostrada em status.</p>

<p>Agora vamos criar o container novamente, mas dessa vez passando uma opção detached, ou seja, vamos criar o container mas não vamos entrar nele. Vamos também dar um nome para nosso container</p>

<pre><code>docker run --name meu-centos -itd centos bash
</code></pre>

<p>Ao rodar docker ps você vê que seu container está rodando, com o comando <strong>bash</strong> e com o nome <strong>meu-centos</strong></p>

<p><strong>Nesse ponto faça o exercício de entrar e sair de containers, criar outros e etc. Use Attach e CTRL+P+Q</strong></p>

<h3>Exec</h3>

<p>As vezes precisamos apenas executar apenas um comando dentro de um container e entrar e sair dele seria muito chato e demorado. Para isso temos o Exec:</p>

<pre><code>docker exec meu-centos echo teste
</code></pre>

<p>Aqui o docker entrou no container, executou o comando <strong>echo teste</strong> em meu-centos e retornou a sua máquina.</p>

<h3>Comandos que você talvez precise</h3>

<pre><code>#Para listar as imagens que você tem: docker images
#Para remover containers: docker rm
#Para remover imagens: docker rmi
#Parar e reiniciar container: docker start / docker stop 
</code></pre>

<h3>Fechando</h3>

<p>Aqui fizemos os pequenos primeiros passos com containers. Muito parecido com o proposto pela documentação oficial.</p>

<p>Te convido a explorar o <a href="https://hub.docker.com/">DockerHUB</a> repositório oficial de imagens para criarmos containers. Procure ferramentas que você já trabalha, ferramentas que você quer experimentar, o uso de containers vai te ajudar a fazer testes rápidos e estudar qualquer coisa.</p>

<p>Com isso acredito que sua cabeça já começe a fervilhar de ideias de para onde podemos ir.
Me comprometo a evoluir esses exemplos aqui nas próximas semanas.</p>

<p>Grande Abraço!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant, PuPHPet E PHP Built In]]></title>
    <link href="http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in/"/>
    <updated>2013-09-15T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2013/vagrant-puphpet-e-php-built-in</id>
    <content type="html"><![CDATA[<p>Fala pessoal.<br/>
Hoje trago uma dica simples, talvez sem uma utilidade de pronto, mas que pode ser interessante para algum estudo.</p>




<p><strong>O que é Vagrant?</strong><br/>
Para quem ainda não conhece, Vagrant é uma ferramenta que vem revolucionando os ambientes de desenvolvimento.<br/>
Se você ainda não sabe nada sobre essa ferramenta, confira o post que escrevi aqui no blog: <a href="http://flaviosilveira.com/2012/vagrant-facil-e-util/">http://flaviosilveira.com/2012/vagrant-facil-e-util/</a>.</p>




<!--more-->




<p>Alguns pontos do Vagrant:<br/>
&#8211; Com o Vagrant você não precisa instalar apache e outras ferramentas e poluir sua máquina.<br/>
&#8211; Você pode criar uma máquina virtual para cada projeto e com isso ter uma versão igual ao seu servidor de produção, com a mesma versão de PHP, de MySQL e etc.<br/>
Com isso acaba aquela desculpa de &#8220;Na minha máquina funciona!&#8221;.<br/>
&#8211; Com o Vagrant você pode distribuir o mesmo ambiente para todo seu time de desenvolvimento, evitando funcionamentos diferentes entre pessoas do mesmo time.<br/>
&#8211; Muito mais.</p>




<p><strong>PuPHPet: Arquivos puppet</strong><br/>
Com arquivos puppet (.pp) você pode definir pacotes, programas e extensões a serem instaladas na sua máquina virtual.<br/>
Geralmente são coisas complicadas e sempre acaba surgindo um problema quando são feitos esses arquivos na mão.</p>




<p>Felizmente surge o PuPHPet <a href="https://puphpet.com/">https://puphpet.com/</a>, uma ferramenta online que cria o puppet para você. Você seleciona tudo o que você quer, incluindo pacotes PEAR, pacotes PECL, etc.<br/>
Permite também setar o XDebug, timezone, escolher versão do PHP, do MySQL, incluir o composer, muito mais.</p>




<p>Dê uma atenção especial na opção BOX IP Address. Nesse campo você define o ip da sua máquina virtual.<br/>
É esse IP que você vai digitar no browser da sua máquina e acessar o seu projeto.<br/>
Por padrão o PuPHPet traz o IP 192.168.56.101.</p>




<p><strong>O que é PHP Built In?</strong><br/>
Com a versão 5.4, o PHP trouxe uma novidade para os ambientes de desenvolvimento. O PHP Buitl In.<br/>
É um web server rodando direto em cima do PHP, mas apenas com propósitos de desenvolvimento.<br/>
Com um simples comando você define a porta da onde quer rodar o servidor, e pronto. Sem precisar de Apache, NGinx ou o que for.<br/>
Uma coisa rápida para testar seu projeto. Veja detalhes na documentação: <a href="http://www.php.net/manual/pt_BR/features.commandline.webserver.php">http://www.php.net/manual/pt_BR/features.commandline.webserver.php</a></p>




<p><strong>Mãos a Obra</strong><br/>
Instale a versão mais recente do Vagrant acessando a página de downloads em <a href="http://downloads.vagrantup.com/">http://downloads.vagrantup.com/</a>.<br/>
Uma dica é ter instalado o Virtual Box para que tudo corra bem. A instalação não tem segredos.</p>




<p>Um segundo passo é configurar a sua máquina com a ajuda do PuPHPet <a href="https://puphpet.com/">https://puphpet.com/</a>.<br/>
Escolha no mínimo uma versão 5.4 do PHP. Faça o download do arquivo e posicione onde melhor julgar na sua máquina.</p>




<p>Via console, acesse essa pasta e vamos subir a sua máquina virtual com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant up
</pre>




<p>Esse comando irá fazer o download de tudo que você selecionou de configuração via PuPHPet e deixar a máquina online para você.<br/>
Ao final da configuração, você já é capaz de acessar a sua máquina via porta 80 por exemplo, digite em seu navegador o ip que foi setado no campo BOX IP Address no PuPHPet.</p>




<p>Mas que tal testar essa funcionalidade que veio com o PHP 5.4? Vamos colocar o PHP Built In para rodar.<br/>
Vamos acessar sua máquina virtual via ssh, com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant ssh
</pre>




<p>Caso você precise do root para qualquer coisa, basta colocar um sudo na frente do que precisar.</p>




<p>Vamos configurar um pequeno projeto PHP apenas para ocasião de teste. Por exemplo:</p>




<pre class="brush: bash; title: ; notranslate" title="">cd /var/www
mkdir teste
cd teste
</pre>




<p>Dentro dessa pasta teste que criamos, crie um arquivo PHP simples, com um echo por exemplo.</p>




<p>Você será capaz de acessar isso digitando seu BOX IP/teste, mas, para testar o PHP Built In, entre com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">sudo php -S 192.168.56.101:8080
</pre>




<p>Não esqueça de substituir 192.168.56.101 pelo seu BOX IP.<br/>
8080 é a porta que escolhemos aqui. Você pode definir a porta que quiser, com exceção das que já estão em uso.<br/>
** Qualquer comando executado nessa mesma janela, ou um ctrl+c irá derrubar o server.</p>




<p>Pronto, o PHP Built In está escutando na porta definida.<br/>
Você pode conferir isso abrindo um outro terminal e consultando os listenings com o comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">netstat -ln
</pre>




<p>Lembrando que esse comando pode variar de acordo com a distribuição que você selecionou na sua BOX.</p>




<p>Pronto. Você pode acessar do seu browser o seu BOX IP:PORTA e acessar o seu projeto diretamente, sem barras nem nada.<br/>
Aqui eu acessei <a href="http://192.168.56.101:8080/.">http://192.168.56.101:8080/.</a></p>




<p><strong>Resumindo</strong><br/>
Escrevi esse post apenas como curiosidade. Sei que ele pode não ter nenhuma aplicação prática, mas de repente é uma para o pessoal conhecer o PHP Built In e ver até onde ele vai e porque ele está apenas disponível para desenvolvimento.</p>




<p>Grande Abraço!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant: Fácil E útil]]></title>
    <link href="http://flaviosilveira.com/2012/vagrant-facil-e-util/"/>
    <updated>2012-11-07T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2012/vagrant-facil-e-util</id>
    <content type="html"><![CDATA[<p>Salve pessoal!</p>




<p>Hoje eu quero passar uma dica para fazer você parar com aquela desculpa &#8220;Na minha máquina tá funcionando&#8221;. Para isso vou apresentar para vocês o Vagrant <a href="http://vagrantup.com/">http://vagrantup.com/</a>.</p>




<p>O Vagrant é uma ferramenta que te ajuda na criação da infraestrutura para o seu projeto, usando para isso uma máquina virtual. Mas aí você pensa: &#8220;Uma máquina virtual para cada projeto?? Isso vai dar trabalho&#8221;. A grande jogada é que o Vagrant deixa muita coisa invísivel, deixando com que você se preocupe apenas com seu código. É uma máquina virtual reduzida e portável facilmente. Para cada projeto você pode deixar um ambiente diferente rodando, um com PHP 4, outro com PHP 5, um em Debian outro em CentOS, você escolhe.</p>




<!--more-->




<p><strong><br/>
Instalação</strong></p>




<p>Para criar suas máquinas vituais o Vagrant precisa do Virtual Box, um cliente de máquinas virtuais da Oracle bastante conhecido. Basta instalar! Você não precisa deixar o programa aberto para usar o Vagrant. Você pode fazer o download do Virtual box no seguinte link <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>.</p>




<p>Instalado o Virtual Box, faça o download do Vagrant e o instale. Procure pela versão do seu sistema operacional no seguinte link <a href="http://downloads.vagrantup.com/">http://downloads.vagrantup.com/</a>.</p>




<p><strong><br/>
Configurando e rodando</strong></p>




<p>Outra coisa que o Vagrant utiliza para criar suas máquinas virtuais são Boxes, ou no singular uma Box. Essa Box funciona como uma imagem, uma iso do sistema operacional que você quer instalar. Então antes de qualquer coisa vamos adicionar uma box, para que você a tenha disponível para criar seu primeiro teste com vagrant.</p>




<p>Abra o console do seu sistema operacional, seja o cmd no windows ou o terminal no linux ou mac e entre com o comando</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant box add lucid32 http://files.vagrantup.com/lucid32.box
</pre>




<p>Essa é a box de exemplo que o Quick Start do Vagrant traz para a gente, onde o primeiro parâmetro que vem após add é o nome que estamos dando a nossa box e o segundo o caminho da onde faremos o download. Esse comando vai trazer uma Box do Ubuntu Lucid. Aqui eu recomendo que caso esteja começando com o Vagrant faça um teste usando essa box, mas caso queira avançar um pouco mais, aqui está uma lista de algumas boxes disponíveis por aí <a href="http://www.vagrantbox.es/">http://www.vagrantbox.es/</a>.</p>




<p>Box preparada, que tal colocar nosso ambiente para rodar?</p>




<p>Crie uma pasta para o seu projeto no seu ambiente de trabalho e acesse ela via console.<br/>
Entre com o seguinte comando:</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant init lucid32
</pre>




<p>Caso tenha usado outro nome para a sua box no passo anterior, substitua no lugar de lucid32 no comando acima.</p>




<p>Como o próprio comando se explica, ele prepara uma configuração inicial para você usando um arquivo que ele cria em seu diretório chamada Vagrantfile. Dentro desse arquivo existe algumas configurações como a box a ser usada entre outros.</p>




<p>Agora é só subir o ambiente.</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant up
</pre>




<p>Ao subir o ambiente o vagrant irá realmente criar sua máquina virtual e configurar as coisas para você. Acompanhe as saídas dos comandos para detalhes.</p>




<p>Tudo pronto!</p>




<p><strong><br/>
Testando</strong></p>




<p>Chegou a hora da verdade. Crie um arquivo html com qualquer conteúdo dentro da pasta do seu projeto.</p>




<p>Por exemplo vamos criar um arquivo chamado teste.html com o seguinte conteúdo</p>




<pre class="brush: xml; title: ; notranslate" title="">&lt;h1&gt;Teste&lt;/h1&gt;
</pre>




<p>Agora acesse via browser a pasta do seu projeto e o arquivo que criou.<br/>
<a href="../../assets/uploads/2012/11/imagem1.png"><img class="alignleft size-full wp-image-587" title="Vagrant - Rodando" src="../../assets/uploads/2012/11/imagem1.png" alt="Vagrant - Rodando" width="394" height="101" /></a><br/>
<br style="clear: both;" /><br/>
Esse HTML está dentro da sua máquina virtual e você está rodando a partir do seu localhost. Muito bom não?</p>




<p>Alguns pontos:</p>




<ul>
<li>Note que você nem abriu essa máquina virtual para trabalhar dentro dela. Você está trabalhando como se ela fosse uma pasta local em sua máquina, essa é a beleza da coisa. Você pode deixar isso melhor organizado usando a opção share_folder do arquivo de configuração Vagrantfile</li>
<li>Mostrei aqui um teste com HTML como também é mostrado no Quick Start do Vagrant, mas você pode instalar o que quiser dentro da sua máquina virtual seja PHP, Java, Python e rodar o que bem entender. Apenas atente para fazer direcionamento das portas para que isso funcione de acordo. Veja a opção forward_port do arquivo de configuração Vagrantfile</li>
<li>Detalhes com todas as opções disponíveis para o Vagrantfile você encontra na documentação oficial <a href="http://vagrantup.com/v1/docs/vagrantfile.html">http://vagrantup.com/v1/docs/vagrantfile.html</a></li>
</ul>




<p><strong><br/>
SSH</strong></p>




<p>E que tal um acesso SSH na sua máquina virtual?<br/>
Sim, o Vagrant te traz isso!<br/>
Se você está no Mac ou Unix apenas entre com o comando abaixo e você está dentro.</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant ssh
</pre>




<p>Para usuários do windows será necessário o uso do puttygen, putty e algumas configurações em cima deles. Nada muito complicado para quem já trabalha com SSH no seu dia a dia.</p>




<p>Após acesar o ssh via vagrant, você sai no seu home <em>/home/vagrant</em>.<br/>
Os arquivos que você criou dentro da pasta do seu projeto podem ser encontrados em <em>/vagrant</em>.</p>




<p><strong><br/>
Distribuindo seu ambiente</strong></p>




<p>Está trabalhando com alguém em um projeto? Que tal enviar esse ambiente que você criou no Vagrant para essa pessoa, para que vocês trabalhem em cima do mesmo ambiente?</p>




<p>Para isso basta criar um pacote da sua máquina virtual com o seguinte comando</p>




<pre class="brush: bash; title: ; notranslate" title="">vagrant package
</pre>




<p>Ao final do processo você terá um arquivo chamado package.box.<br/>
Para que alguém ou você mesmo o utilize, basta seguir os passos apresentados aqui como se esse arquivo fosse uma box que você vai fazer o download. Sem mais.</p>




<p><strong><br/>
Resumo</strong></p>




<p>Apresentei aqui uma geral sobre o Vagrant, porque ele é útil, porque é interessante usá-lo e etc. Fizemos um exemplo e vimos como distribuir esse ambiente com mais pessoas. Cobri aqui o básico dessa sensacional ferramenta para você configurar o ambiente de seus projetos individualmente.</p>




<p>Você pode ir mais além e criar várias máquinas virtuais que se comunicam entre si e outros. Para isso leia a documentação <a href="http://vagrantup.com/v1/docs/index.html">http://vagrantup.com/v1/docs/index.html</a> e se intere do que mais o Vagrant pode fazer por você.</p>




<p>É isso pessoal.<br/>
Abraços.</p>

]]></content>
  </entry>
  
</feed>
