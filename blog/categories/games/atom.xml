<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Games | Flávio Silveira]]></title>
  <link href="http://flaviosilveira.com/blog/categories/games/atom.xml" rel="self"/>
  <link href="http://flaviosilveira.com/"/>
  <updated>2016-10-23T18:38:10+00:00</updated>
  <id>http://flaviosilveira.com/</id>
  <author>
    <name><![CDATA[Flávio Silveira]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Evoluindo Seu Primeiro Jogo Em HTML5]]></title>
    <link href="http://flaviosilveira.com/2014/evoluindo-seu-primeiro-jogo-em-html5/"/>
    <updated>2014-02-17T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2014/evoluindo-seu-primeiro-jogo-em-html5</id>
    <content type="html"><![CDATA[<p>O post de hoje é uma continuação do anteriormente escrito Seu primeiro jogo em HTML5. O objetivo dessa continuação é aprender mais alguns conceitos de desenvolvimento de jogos e animar um pouco o nosso game que não estava lá essas coisas de divertido. Você acompanha a primeira parte no seguinte link <a href="http://flaviosilveira.com/2013/seu-primeiro-jogo-em-html5/" title="Seu primeiro jogo em HTML5 - Parte 1">http://flaviosilveira.com/2013/seu-primeiro-jogo-em-html5/</a>.</p>




<!--more-->




<p>Nessa continuação vamos adicionar um pouco de jogabilidade, variando a velocidade das bolas que caem e também seu tamanho e a sua pontuação.</p>




<p><strong>Objeto</strong><br/>
Estamos querendo tipos diferentes de bolas. Tamanhos diferente, velocidades diferentes, pontos diferentes. Ainda são bolas, mas cada uma de um jeito, certo?<br/>
Estamos falando então de uma mesma coisa, mas com características e comportamentos diferentes, concorda?</p>




<p>Vamos entrar aqui então com o conceito de programação orientada a objetos para resolver o problema.<br/>
Dependendo do seu nível em programação, esse pode ser um conceito novo e, se esse é o caso, você vai precisar fazer algumas pesquisas caso queira entender melhor alguns pontos. Se você não conhece Orientação a Objetos recomendo que pare a leitura aqui e pesquise á respeito e também como é aplicado na linguagem javaScript. Não é necessário um conhecimento profundo neste momento, dê aquela lida no conceito, faça um exemplos simples em um papel e volte a leitura do post. Caso você já entenda o suficiente desse conceito é seguir em frente.</p>




<p>Precisamos então programar algo que crie as bolas para a gente, uma fôrma das bolas, que é equivalente a uma classe em orientação a objetos. Em javaScript não temos classes propriamente ditas, tudo que precisamos fazer é uma função.</p>




<p>Pegue então o código que desenvolvemos no post anterior.<br/>
Antes da nossa função inicializar, vamos criar uma função chamada bola e dentro dela vamos colocar todas as variáveis iniciais referente a bola que estão hoje na função inicializar.<br/>
Veja como fica:</p>




<pre class="brush: jscript; title: ; notranslate" title="">function bola()
    {
                bolaDiametro = 10;
                bolaPosX = canvas.width / 2;
                bolaPosY = -10;
        velocidadeBola = 10;
        colisao = false;
    }
        
    function inicializar()
    {
        barraAltura = 15;
        barraLargura = 90;

        pontosJogador = 0;
        jogadorPosicaoX = (canvas.width - barraLargura) / 2;
        velocidadeJogador = 20;
                
        canvas = document.getElementById("canvas");
        context = canvas.getContext("2d");              
                
        document.addEventListener('keydown', keyDown);
                
        setInterval(gameLoop, 30);
    }
</pre>




<p>Dentro da função inicializar vamos criar a primeira bola e adicionar ela dentro de um array. Esse array vai guardar todas as bolas que estiverem em cena. Dessa maneira teremos controle sobre elas.</p>




<pre class="brush: jscript; title: ; notranslate" title="">function inicializar()
    {
        …     
        var primeira = new bola()
        bolas = new Array(primeira);
        …
    }
</pre>




<p>Rodando o seu código nesse momento verá que está tudo como antes. A questão é que nesse ponto não estamos utilizando nenhum conceito novo. Tudo que foi feito foi adicionar o código de antes para uma função, e chamar ela. Nem estamos trabalhando com o array criado não é mesmo?</p>




<p>Vamos trocar a nossa função para ela realmente virar um objeto, com propriedades. Para isso adicione a palavra chave this a frente de todas as variáveis.<br/>
Essa palavra chave fará referência para aquela instância de objeto e apenas ela. Caso não entenda isso aqui, talvez você entenda melhor quando trabalharmos com o array das bolas que estão em cena.</p>




<pre class="brush: jscript; title: ; notranslate" title="">function bola()
{
    this.bolaDiametro = 10;
    this.bolaPosX = canvas.width / 2;
    this.bolaPosY = -10;
    this.velocidadeBola = 10;
    this.colisao = false;
}
</pre>




<p>Neste momento o game para de funcionar. Isso porque as variáveis que temos dentro de nosso gameLoop já não existem mais. Temos agora um objeto bola e esse objeto adicionado a um array que é responsável por todas as bolas em cena. Precisamos trabalhar com esse array para as coisas voltarem a funcionar.</p>




<p>Para questão de organização, já que as variáveis que definiam as características da bola não nos servem mais, podemos limpar elas da nossa definição inicial na primeira linha de javaScript. Mas não esqueça de adicionar a variável para o nosso array de bolas, para que fique acessível para todo o resto do código. Ficando assim:</p>




<pre class="brush: jscript; title: ; notranslate" title="">var barraAltura, barraLargura, jogadorPosicaoX, velocidadeJogador, pontosJogador, bolas;
</pre>




<p>Agora vá até a função de gameLoop, e repare onde está a lógica da bola. Começa onde iniciamos com o desenho dela e termina com a verificação da colisão.<br/>
O que vamos fazer aqui é tirar tudo isso, e aplicar para cada objeto dentro do array bolas usando um foreach. Fica dessa forma:</p>




<pre class="brush: jscript; title: ; notranslate" title="">// Bola
bolas.forEach(function(bola, indice){
    context.beginPath();
    context.arc(b.bolaPosX, b.bolaPosY, b.bolaDiametro, 0, Math.PI * 2, true);
    context.fill();
                
    if(bola.bolaPosY &lt;= canvas.height)
    {
        bola.bolaPosY += bola.velocidadeBola;
    }
    else
    {
        bola.bolaPosX = Math.random() * 600;
        bola.bolaPosY = -10;
        bola.colisao = false;
    }
                
    // Checar Colisão
    if((bola.bolaPosX &gt; jogadorPosicaoX && bola.bolaPosX &lt; jogadorPosicaoX + barraLargura) && bola.bolaPosY &gt;= canvas.height - barraAltura && bola.colisao == false)
    {
        pontosJogador++;
        bola.colisao = true;
    }
});
</pre>




<p>Na função de forEach do javaScript o primeiro parâmetro é o elemento em si e o segundo o indíce.<br/>
Para cada objeto dentro do array, ele vai executar uma vez.<br/>
Note que agora nas variáveis com as características da bola de antes, adicionamos “b.”. É dessa maneira que acessamos as propriedades do objeto.<br/>
Tome cuidado para não adicionar isso nas variáveis do jogador nem do canvas.<br/>
Neste ponto se jogo volta a funcionar como antes, mas dessa vez usando bola com o conceito de orientação a objetos.</p>




<p><strong>Cada bola um Objeto</strong><br/>
Olhe o código e verá que quando a bola chega ao final do canvas ou quando ela colide com o jogador, não criamos uma nova, apenas editamos novamente as propriedades do mesmo objeto que foi criado da primeira vez. Vamos mudar isso alterando o if que checa se a bola já passou do canvas. Agora quando ela passar do canvas, vamos retirar ela do nosso array usando a função splice do javaScript.</p>




<pre class="brush: jscript; title: ; notranslate" title="">if(bola.bolaPosY &lt;= canvas.height)
    {
        bola.bolaPosY += bola.velocidadeBola;
    }
    else
    {
        bolas.splice(indice, 1);
    }
</pre>




<p>Tudo que estava dentro do else, que era usado para criar uma nova bola, não é mais necessário. Trocamos tudo isso pela função splice.<br/>
Splice irá retirar um item do array baseado em seu índice. O primeiro parâmetro é o índice que queremos tirar e o segundo é a quantidade de índices a partir dele, que para nós será sempre 1.</p>




<p>Rodando seu game agora, quando a bola passa pelo canvas, não é criado nenhuma nova.</p>




<p><strong>Criando uma nova bola</strong><br/>
Nosso foreach só é executado se tivermos bolas dentro dele. Como nossa primeira bola passou pelo canvas e foi destruída, vamos adicionar uma verificação antes do foreach para caso nosso array estiver vazio, criar uma nova bola dentro dele. Para isso vamos usar um push. Veja como fica:</p>




<pre class="brush: jscript; title: ; notranslate" title="">if(bolas.length &lt;= 0)
{
    bolas.push(new bola());
}
</pre>




<p>Certo, mas todas as bolas estão saindo no mesmo lugar. Dá para ganhar o jogo parado!<br/>
Isso está acontecendo por conta da posição X e Y estarem fixas dentro da criação do nosso objeto.<br/>
Vamos alterar isso com a ajuda da classe Math de javaScript.</p>




<pre class="brush: jscript; title: ; notranslate" title="">function bola()
{
    this.bolaDiametro = 10;
    this.bolaPosX = Math.random() * 600;
    this.bolaPosY = -10;
    this.velocidadeBola = 10;
    this.colisao = false;
}
</pre>




<p>A posição Y da bola pode continuar sendo -10 para aparecer antes do canvas. Mas para deixar a posição X randômica, use Math.random multiplicando pela largura do seu canvas.</p>




<p>Use um pouco da matemática aqui para alterar também a velocidade de sua bola.</p>




<pre class="brush: jscript; title: ; notranslate" title="">function bola()
{
    this.bolaDiametro = 10;
    this.bolaPosX = Math.random() * 600;
    this.bolaPosY = -10;
    this.velocidadeBola = Math.random() * (10 - 6) + 6;
    this.colisao = false;
}
</pre>




<p>No exemplo acima temos velocidades entre 10 e 6.<br/>
Acima você vê como obter um número randômico entre um mínimo e um máximo. Math.random multiplicado pelo máximo diminuindo o mínimo e somado ao mínimo.<br/>
Caso queira tentar entender o “truque” acima lembre-se que Math.random retorna um número entre 0 e 1.</p>




<p><strong>Diâmetros e pontos variados</strong><br/>
Para termos diâmetros variados e pontos baseados nesse diâmetro, vamos primeiro definir isso em um array, antes do nosso objeto bola.<br/>
Nesse array, criamos um objeto que tem um dâimetro e uma pontuação.</p>




<pre class="brush: jscript; title: ; notranslate" title="">var barraAltura, barraLargura, jogadorPosicaoX, velocidadeJogador, pontosJogador, bolas;
        
var diametros = new Array(
    {'diametro' : 7, 'pontos' : 1},
    {'diametro' : 10, 'pontos' : 2},
    {'diametro' : 15, 'pontos' : 3}
);
</pre>




<p>Com isso definido, vamos agora usar a mesma fórmula que usamos acima para pegar um número randômico que esteja dentro dos valores desse array. Lembrando que o array começa em 0, então vamos diminuir um ao final. Vamos armazenar esse número, e usar ele para o tamanho da bola e consequentemente sua pontuação. Veja como fica:</p>




<pre class="brush: jscript; title: ; notranslate" title="">function bola()
{
    var indice = Math.round(Math.random() * (3 - 1) + 1) - 1;
    this.bolaDiametro = diametros[indice]['diametro'];
    this.pontos = diametros[indice]['pontos'];
                
    this.bolaPosX = Math.random() * 600;
    this.bolaPosY = -10;
    this.velocidadeBola = Math.random() * (10 - 6) + 6;
    this.colisao = false;
}
</pre>




<p>Neste momento os tamanhos de bolas já aparecem diferentes na tela. Mas a pontuação continua somando 1 sempre.<br/>
Precisamos alterar nosso gameLoop para pegar os pontos do objeto em questão. Veja como:</p>




<pre class="brush: jscript; title: ; notranslate" title="">if((bola.bolaPosX &gt; jogadorPosicaoX && bola.bolaPosX &lt; jogadorPosicaoX + barraLargura) && bola.bolaPosY &gt;= canvas.height - barraAltura && bola.colisao == false)
{
    pontosJogador += bola.pontos;
    bola.colisao = true;
}
</pre>




<p>Trocamos o incrementar que tinha antes para um += que vai pegar o valor que já tinha na variável e somar o valor dos pontos daquela bola que colidiu.</p>




<p>Mais de uma ao mesmo tempo e tudo junto<br/>
Para finalizar, que tal deixar cair mais de uma bola ao mesmo tempo?</p>




<p>Para fazer isso de forma bem simples, adicione dentro do foreach um verificação para caso aquela bola já tenha passado da posição 50 em Y, criar uma nova.</p>




<pre class="brush: jscript; title: ; notranslate" title="">// Criar nova bola?
if(bola.bolaPosY &gt;= 50 && bolas.length &lt;= 2)
{
    bolas.push(new bola());
}
</pre>




<p>Cuidado! Veja no código acima que eu também verifiquei quantas bolas estão em cena antes de adicionar uma nova. Caso contrário você vai ter um efeito matrix em sua tela e travar seu navegador. Tente por sua conta e risco :).</p>




<p><strong>Conclusão</strong><br/>
Você pode aplicar o conceito de orientação a objetos para tudo o que for objeto na tela. Dessa maneira você vai ter um melhor controle das coisas e é a maneira correta de trabalhar em jogos.</p>




<p>Acompanhe o repositório gitHub dessa série em <a href="https://github.com/flaviosilveira/primeiro-jogo-html5" title="Git Hub - Seu primeiro jogo em HTML5">https://github.com/flaviosilveira/primeiro-jogo-html5</a>.</p>




<p>Aguarde o próximo post da série. Abraços!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seu Primeiro Jogo Em HTML5]]></title>
    <link href="http://flaviosilveira.com/2013/seu-primeiro-jogo-em-html5/"/>
    <updated>2013-09-19T00:00:00+00:00</updated>
    <id>http://flaviosilveira.com/2013/seu-primeiro-jogo-em-html5</id>
    <content type="html"><![CDATA[<p>Hoje quero ajudar você a desenvolver seu primeiro jogo, que talvez não fique aquele delírio de diversão, mas é o primeiro passo para você começar a entrar nesse mundo de desenvolvimento de jogos. E para isso vamos usar tecnologias que você tem em mãos no seu navegador. HTML5 e javascript.</p>




<p>Vou passo a passo, tentando deixar claro o porque de algumas coisas primordiais em desenvolvimento de jogos. Cometendo erros para depois corrigi-los. Isso talvez torne o post um pouco extenso, então busque sua garrafa de água para manter seu cérebro hidratado.</p>




<!--more-->




<p>Para os sem saco, no final do post você tem um link para o código completo.</p>




<p><strong>O Jogo</strong><br/>
Eu havia pensado em desenvolver um <a href="http://en.wikipedia.org/wiki/Arkanoid">Arkanoid</a> para esse post, mas a criação e a lógica subiriam um pouco de nível e a intenção de começar devagar iria se perder. Então temos algo bem mais simples, bolas que caem do topo da tela e que você deve resgatá-las com a plataforma.<br/>
<img src="../../../assets/uploads/2013/09/Imagem1-300x240.png" alt="" title="Imagem1" width="300" height="240" class="alignnone size-medium wp-image-660" /><br style="clear:both;" /></p>




<p><strong>HTML</strong><br/>
Para montar o desenho da tela, o jogador e a bola, vamos usar a tag canvas. Ela está presente há algum tempo nos navegadores, tendo começado no Safari da Apple, mas ganhou mais popularidade recentemente com o HTML5.</p>




<p>Crie um arquivo HTML com qualquer nome e dentro dele crie um Canvas.</p>




<pre class="brush: xml; title: ; notranslate" title="">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Seu Primeiro Jogo - HTML5&lt;/title&gt;
    &lt;/head&gt;   
    &lt;body&gt;
        &lt;canvas id="canvas" width="600" height="480"&gt;
            Navegador não suporta HTML5
        &lt;/canvas&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>




<p>Usamos o Doctype do HTML5 junto com um título.<br/>
Dentro da tag body vemos o canvas, onde definimos uma largura e uma altura.</p>




<p>Carregando isso no navegador, não vemos nada. Mas não se preocupe, você não fez nada de errado. Vamos com ajuda de um CSS definir uma borda para nosso canvas, assim vamos ver ele na tela. Nosso head vai ficar como abaixo.</p>




<pre class="brush: xml; title: ; notranslate" title="">&lt;head&gt;
    &lt;title&gt;Seu Primeiro Jogo - HTML5&lt;/title&gt;
     &lt;style type="text/css"&gt;
    canvas {
        border: 1px solid #000000;
    }
     &lt;/style&gt;
&lt;/head&gt;  
</pre>




<p>Fique a vontade para alterar a cor, o tipo da borda ou o que mais quiser nesse CSS.</p>




<p>Nosso trabalho com HTML acaba aqui. Tudo o que vamos usar agora é JavaScript. Para isso vamos então chamar uma função javaScript quando o body estiver totalmente carregado, da seguinte maneira.</p>




<pre class="brush: xml; title: ; notranslate" title="">&lt;body onload="inicializar()"&gt;
</pre>




<p><strong>JavaScript</strong><br/>
Vamos criar nosso JavaScript no mesmo arquivo do HTML. Nosso intuito não é discutir arquitetura aqui. Vamos criar uma tag script logo depois de nosso canvas, e já vamos definir nossa função inicializar que chamamos acima.</p>




<pre class="brush: jscript; title: ; notranslate" title="">&lt;script type="text/javascript"&gt;
function inicializar()
{
 // Nosso código aqui
}
&lt;/script&gt;
</pre>




<p><strong>Jogador</strong><br/>
Vamos começar desenhando o jogador, que nada mais é do que uma barra.</p>




<p>Vamos iniciar algumas variáveis acima da nossa função. barraAltura e barraLargura.<br/>
Em seguida em nossa função inicializar setamos os valores desejados para elas.</p>




<p>Para desenhar com o canvas, precisamos capturar o elemento com javaScript e usar o contexto que no nosso caso vai ser 2D.</p>




<p>O método para desenhar retângulos com canvas é fillRect. Essa função nos pede a posição do elemento (pontos X e Y), sua largura e sua altura.</p>




<p>Como a posição X (horizontal) do jogador vai ficar mudando, vamos criar uma variável para isso também. Já a posição Y (vertical) como não vai mudar, podemos deixá-la fixa usando a altura do canvas menos o tamanho da barra.</p>




<p>Confira o código abaixo com as explicações acima:</p>




<pre class="brush: jscript; title: ; notranslate" title="">var barraAltura, barraLargura, jogadorPosicaoX;
        
function inicializar()
{
    barraAltura = 15;
    barraLargura = 90;

    jogadorPosicaoX = 0;

    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");

    context.fillRect(jogadorPosicaoX, canvas.height - barraAltura, barraLargura, barraAltura);
}
</pre>




<p>Resultado na tela:<br/>
<img src="../../../assets/uploads/2013/09/imagem2-300x240.png" alt="" title="imagem2" width="300" height="240" class="alignnone size-medium wp-image-659" /><br style="clear: both;" /></p>




<p>Nosso jogador não ficou centralizado, porque definimos sua posição X como 0, ou seja, o canto esquerdo do canvas.<br/>
Altere os valores de pouco em pouco para você perceber como o jogador irá se mover, isso também irá ajudar na lógica de colisão mais para frente. Entendido isso, vamos deixar nosso jogador centralizado, pegando o tamanho do canvas e dividindo por 2.</p>




<p>Ao atualizar seu browser e conferir o resultado nesse ponto não se preocupe, você não está com problema na vista. É necessário diminuir o tamanho da barra para que o jogador fique exatamente no centro do canvas. Ficando então da seguinte maneira.</p>




<pre class="brush: jscript; title: ; notranslate" title="">jogadorPosicaoX = (canvas.width - barraLargura) / 2;
</pre>




<p>Use os parênteses para fazer a subtração primeiro.</p>




<p><strong>Comandos do jogador</strong><br/>
É hora de dar vida ao jogador.<br/>
O que queremos é que quando for pressionado para a direita, para esquerda, a nossa barra obedeça isso.</p>




<p>Vamos deixar nosso javaScript de olho quando o jogador apertar alguma tecla com os Event Listeners do javaScript.</p>




<p>Então definimos a função desse listener. Aqui no meu notebook, o código das teclas para esquerda e para direita são respectivamente 37 e 39. Isso pode variar se você tem um tipo diferente de teclado ou ainda se quiser outras teclas de comando.</p>




<p>Vamos agora reposicionar o jogador de acordo com as teclas pressionadas.<br/>
Se apertar a tecla código 37, esquerda, diminuimos a posição do jogador. Se apertar a tecla código 39 vamos somar.</p>




<p>Mas vamos somar/diminuir quanto? Vamos definir uma variável para a velocidade do jogador, essa velocidade será a quantidade de pixels que o jogador se movimenta a cada vez que é pressionado as teclas. Voltando então, se pressionar para a direita somamos a velocidade do jogador, se pressionar para a esquerda diminuimos a velocidade do jogador.</p>




<p>Não esqueça de desenhar a barra novamente com a posição nova do jogador.</p>




<p>Confira o código abaixo:</p>




<pre class="brush: jscript; title: ; notranslate" title="">var barraAltura, barraLargura, jogadorPosicaoX, velocidadeJogador;
        
function inicializar() ...
    velocidadeJogador = 20;
    ...
    document.addEventListener('keydown', keyDown);
}
            
function keyDown(e) 
{
    if(e.keyCode == 37)
    {
        jogadorPosicaoX -= velocidadeJogador;
    }
                
    if(e.keyCode == 39)
    {
        jogadorPosicaoX += velocidadeJogador;
    }

    context.fillRect(jogadorPosicaoX, canvas.height - barraAltura, barraLargura, barraAltura);
}
</pre>




<p>Atualizando nossa tela e apertando as teclas você vê o resultado.<br/>
<img src="../../../assets/uploads/2013/09/Imagem3-300x241.png" alt="" title="Imagem3" width="300" height="241" class="alignnone size-medium wp-image-658" /><br style="clear: both;" /></p>




<p>Percebe um problema? Temos dois na verdade, mas vamos um de cada vez.<br/>
O primeiro é que não estamos apagando a posição anterior do jogador. Estamos então tendo a sensação de que a barra está aumentando de tamanho.</p>




<p>Para resolver isso temos que entender um conceito no desenvolvimento de jogos que é o GameLoop.<br/>
Não vou entrar em detalhes á fundo, mas acompanhe.</p>




<p><strong>Game Loop &#8211; Explicação ultra simples</strong><br/>
Um jogo não passa de um loop infinito. Se você perde, você volta ao começo.<br/>
Então pense em um loop que contêm algumas verificações dentro dele que serão os comandos do jogador, pontuação e etc.</p>




<p>Durante esse loop, os inimigos, o jogador e outras coisas na tela irão mudar de posição o tempo todo.<br/>
Mas você deve apagar a posição anterior caso contrário vai ficar um efeito como o que estamos tendo.</p>




<p>Então vamos apagar tudo da tela e fazer aparecer novamente. Ok!<br/>
Mas isso não pode ser visível ao jogador, a tela não pode parecer que está piscando.<br/>
Então vamos definir um tempo, um certo número de frames que não permita que o jogador perceba isso.</p>




<p>Então vamos re-estruturar nosso código, pensando nesse conceito.</p>




<p>No topo temos a definição das variáveis.</p>




<p>Em seguida na função inicializar, vamos deixar apenas o valor inicial das variável e o listener, e de dentro dela chamar o gameLoop.<br/>
Para o loop, vamos usar setInterval e chamar nossa função a cada 30 milisegundos.<br/>
Ficando assim:</p>




<pre class="brush: jscript; title: ; notranslate" title="">var barraAltura, barraLargura, jogadorPosicaoX, velocidadeJogador;
        
function inicializar()
{
    barraAltura = 15;
    barraLargura = 90;

    jogadorPosicaoX = (canvas.width - barraLargura) / 2;
    velocidadeJogador = 20;

    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");              

    document.addEventListener('keydown', keyDown);

    setInterval(gameLoop, 30);
}
</pre>




<p>Seguimos o código com a função keyDown que fizemos acima, mas já vamos resolver nosso segundo problema que não comentei anteriormente. O jogador não pode continuar indo para a direita ou para esquerda se ele chegar aos limites do canvas. Então adicionamos algumas verificações para isso. Repare também que não vamos mais redesenhar a tela a partir dessa função.</p>




<pre class="brush: jscript; title: ; notranslate" title="">function keyDown(e) 
{
    if(e.keyCode == 37)
    {
        if(jogadorPosicaoX &gt; 0)
        {
            jogadorPosicaoX -= velocidadeJogador;
        }
    }

    if(e.keyCode == 39)
    {
        if(jogadorPosicaoX &lt; (canvas.width - barraLargura))
        {
            jogadorPosicaoX += velocidadeJogador;
        }
    }
}
</pre>




<p>Por último nosso gameLoop. Ele contém uma função que desenha um retângulo em branco em cima de toda a área do canvas.<br/>
Isso limpa a nossa tela. E em seguida redesenhamos nosso jogador.</p>




<pre class="brush: jscript; title: ; notranslate" title="">function gameLoop()
{
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.fillRect(jogadorPosicaoX, canvas.height - barraAltura, barraLargura, barraAltura);
}
Recarregue sua tela e se divirta movimentando a barra.

&lt;strong&gt;Bola&lt;/strong&gt;
Vamos primeiro desenhar uma bola parada no topo da tela.
Vamos definir algumas configurações para ela. Diâmetro, posição X, posição Y e sua velocidade.
1
var barraAltura, barraLargura, jogadorPosicaoX, velocidadeJogador, bolaDiametro, bolaPosX, bolaPosY, velocidadeBola;
        
function inicializar()
{
    ...
    bolaDiametro = 10;
    bolaPosX = canvas.width / 2;
    bolaPosY = 0;
    velocidadeBola = 10;
    ...
}
</pre>




<p>Para desenhar a bola, adicione as seguintes linhas dentro de gameLoop.</p>




<pre class="brush: jscript; title: ; notranslate" title="">function gameLoop()
{
    ...
    context.beginPath();
    context.arc(bolaPosX, bolaPosY, bolaDiametro, 0, Math.PI * 2, true);
    context.fill();
    ...
}
</pre>




<p>Procure pesquisar some a função de desenho do arco que usamos acima. Foge do mérito desse artigo explicá-la.</p>




<p>Como resultado você deve ver metade da bola desenhada no topo do canvas. Como abaixo:<br/>
<img src="../../../assets/uploads/2013/09/Imagem4-300x240.png" alt="" title="Imagem4" width="300" height="240" class="alignnone size-medium wp-image-657" /><br style="clear: both;" /></p>




<p>Vemos metade dela pois ela é desenhada a partir do centro, como setamos Y para 0, a outra metade está acima do canvas.<br/>
Sendo desenhada do centro, não precisamos diminuir seu diâmetro para centralizar ela na tela, bastou dividir por 2 o eixo X.</p>




<p><strong>Movimentando a bola</strong><br/>
Bom, não queremos que a bola inicia com metade aparecendo, melhor que isso queremos que ela venha antes do canvas.<br/>
Você pode setar o valor de bolaPosY para -10 para que isso aconteça.</p>




<pre class="brush: jscript; title: ; notranslate" title="">...
    bolaPosY = -10;
    ...
</pre>




<p>Agora vamos movimentar ela como se estivesse caindo, no eixo Y.<br/>
Simples não? Basta a cada gameLoop diminuir a velocidade da bola.</p>




<p>Mas veja que isso só pode acontecer se a posição Y da bola for menor que a altura do canvas, caso contrário a bola vai descer até o infinito.</p>




<p>E já que a bola chegou ao fim do canvas, que tal iniciar outra lá no topo?</p>




<p>Acompanhe isso no trecho abaixo:</p>




<pre class="brush: jscript; title: ; notranslate" title="">...
if(bolaPosY &lt;= canvas.height)
{
    bolaPosY += velocidadeBola;
}
else
{
    bolaPosY = -10;
}
...
</pre>




<p>Legal! Mas o jogo já não é muito divertido, se a bola ficar caindo sempre no mesmo lugar então.<br/>
Vamos adicionar um cálculo para fazer a posição X da bola variar cada vez que é criada uma nova.<br/>
Basta reformular o nosso else acima.</p>




<pre class="brush: jscript; title: ; notranslate" title="">...
else
{
    bolaPosX = Math.random() * 600;
    bolaPosY = -10;
}
...
</pre>




<p>Você já pode ir treinando para o game final agora.</p>




<p><strong>Colisão</strong><br/>
Chegou a hora de checar se a bola colide com a barra e com isso marcar pontos para você.</p>




<p>Vamos definir uma variável pontosJogador. Não esqueça de iniciá-la como zero dentro da função inicializar.</p>




<pre class="brush: jscript; title: ; notranslate" title="">var barraAltura, barraLargura, jogadorPosicaoX, velocidadeJogador, bolaDiametro, bolaPosX, bolaPosY, velocidadeBola, pontosJogador;

function inicializar()
{
    ...
    pontosJogador = 0;
    ...
}
</pre>




<p>Em seguida vamos pensar na matemática da colisão.<br/>
Temos que fazer um cálculo que coloque a bola em cima da barra.<br/>
Então primeiramente, a posição X da bola tem de ser maior que a posição X da barra.<br/>
Mas também essa posição X da bola tem de ser menor que a posição X da barra + o tamanho dela.<br/>
Lembrando que na barra, sua posição X é o início dela, no canto esquerdo, por isso somamos a sua largura.</p>




<p>Não podemos bater apenas o ponto X. O eixo Y da bola tem de ser maior ou igual que a altura do canvas menos a altura da barra.</p>




<p>Dentro do IF da colisão incrementamos os pontos do jogador.</p>




<p>Em seguida temos um código para escrever a pontuação na tela.</p>




<p>Confira o código abaixo com a explicação acima:</p>




<pre class="brush: jscript; title: ; notranslate" title="">if((bolaPosX &gt; jogadorPosicaoX && bolaPosX &lt; jogadorPosicaoX + barraWidth) && bolaPosY &gt;= canvas.height - barraHeight)
{
    pontosJogador++;
}

context.font = "32pt Tahoma";
context.fillText(pontosJogador, canvas.width - 70, 50);
</pre>




<p>Hora de rodar o seu jogo!<br/>
<img src="../../../assets/uploads/2013/09/Imagem5-300x241.png" alt="" title="Imagem5" width="300" height="241" class="alignnone size-medium wp-image-656" /><br style="clear: both;" /></p>




<p>Mas espere! Isso não é basquete e a cada bola que pegamos estamos fazendo 3 pontos ou mais.<br/>
Porque isso está acontecendo?</p>




<p>Ah, simples! Como refazemos a tela a cada 30 milesegundos, a bola leva muito mais tempo que isso para passar pela barra. Então ela está caindo no IF de colisão mais de uma vez.</p>




<p>Para resolver isso vamos adicionar uma flag dizendo se colidiu ou não.<br/>
Vamos primeiro definir essa variável, em seguida inicializar ela como false.</p>




<pre class="brush: jscript; title: ; notranslate" title="">var barraAltura, barraLargura, jogadorPosicaoX, velocidadeJogador, bolaDiametro, bolaPosX, bolaPosY, velocidadeBola, pontosJogador, colisao;

function inicializar()
{
    ...
    colisao = false;
    ...
}
</pre>




<p>Agora no IF onde checamos a colisão, mudamos o valor para true quando colidir, e antes de checar se colidiu verificamos se esse status ainda é false.</p>




<pre class="brush: jscript; title: ; notranslate" title="">if((bolaPosX &gt; jogadorPosicaoX && bolaPosX &lt; jogadorPosicaoX + barraLargura) && bolaPosY &gt;= canvas.height - barraAltura && colisao == false)
{
    pontosJogador++;
    colisao = true;
}
</pre>




<p>Por último, se uma bola nova começa a cair ela tem de vir com esse status como falso.<br/>
Lembra do nosso else que cria uma nova bola no eixo X?</p>




<pre class="brush: jscript; title: ; notranslate" title="">...
else
{
    bolaPosX = Math.random() * 600;
    bolaPosY = -10;
    colisao = false;
}
...
</pre>




<p>Feito! Hora de chamar os amigos e iniciar um campeonato.</p>




<p><strong>Conclusão</strong><br/>
Estude alterando as variáveis como velocidade do jogador, velocidade da bola e etc.<br/>
A partir daqui pode surgir muita coisa. Quem sabe não continuamos desenvolvendo esse jogo em um próximo post?</p>




<p>Código completo aqui: <a href="https://github.com/flaviosilveira/primeiro-jogo-html5">https://github.com/flaviosilveira/primeiro-jogo-html5</a></p>




<p>Abraço!</p>

]]></content>
  </entry>
  
</feed>
